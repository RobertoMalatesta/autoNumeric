(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0 - 2016-11-27 UTC 11:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\n * Defaults options are public - these can be overridden by the following:\n * - HTML5 data attributes\n * - Options passed by the 'init' or 'update' methods\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nvar defaultSettings = {\n    /* Allowed thousand separator characters\n     * comma = \",\"\n     * period \"full stop\" = \".\"\n     * apostrophe is escaped = \"\\\"\"\n     * space = \" \"\n     * none = \"\"\n     * NOTE: do not use numeric characters\n     */\n    aSep: ',',\n\n    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     */\n    nSep: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n     * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * dGroup: \"3\", results in 999,999,999 default\n     * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n     */\n    dGroup: '3',\n\n    /* Allowed decimal separator characters\n     * period \"full stop\" = \".\"\n     * comma = \",\"\n     */\n    aDec: '.',\n\n    /* Allow to declare alternative decimal separator which is automatically replaced by aDec\n     * developed for countries the use a comma \",\" as the decimal character\n     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n     */\n    altDec: null,\n\n    /* aSign = allowed currency symbol\n     * Must be in quotes aSign: \"$\"\n     * space to the right of the currency symbol aSign: '$ '\n     * space to the left of the currency symbol aSign: ' $'\n     */\n    aSign: '',\n\n    /* pSign = placement of currency sign as a p=prefix or s=suffix\n     * for prefix pSign: \"p\" (default)\n     * for suffix pSign: \"s\"\n     */\n    pSign: 'p',\n\n    /* Placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {aSign: \"$\"}\n     * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n     * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n     * 1,234.56-  => {pNeg: \"s\"}\n     * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n     * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n     * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n     */\n    pNeg: 'l',\n\n    /* Additional suffix\n     * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     */\n    aSuffix: '',\n\n    /* Override min max limits\n     * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n     * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n     * oLimits: \"ignore\" ignores both vMin & vMax\n     */\n    oLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than vMin\n     */\n    vMax: '9999999999999.99',\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than vMax\n     */\n    vMin: '-9999999999999.99',\n\n    /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n     * value must be enclosed in quotes example mDec: \"3\",\n     */\n    mDec: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     */\n    eDec: null,\n\n    /* The next three options (scaleDivisor, scaleDecimal & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"aStor\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimal: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimal` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     */\n    scaleDecimal: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the eDec value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     */\n    aStor: false,\n\n    /* method used for rounding\n     * mRound: \"S\", Round-Half-Up Symmetric (default)\n     * mRound: \"A\", Round-Half-Up Asymmetric\n     * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n     * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n     * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * mRound: \"U05\" Rounds up to next .05\n     * mRound: \"D05\" Rounds down to next .05\n     */\n    mRound: 'S',\n\n    /* Controls decimal padding\n     * aPad: true - always Pad decimals with zeros\n     * aPad: false - does not pad with zeros.\n     * Note: setting aPad to 'false' will override the 'mDec' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     */\n    aPad: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * nBracket: null - (default)\n     * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n     */\n    nBracket: null,\n\n    /* Displayed on empty string \"\"\n     * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n     * wEmpty: \"press\" - currency sign displays on any key being pressed\n     * wEmpty: \"always\" - always displays the currency sign only\n     * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or with a currency sign\n     */\n    //TODO Add an option to display the currency sign only on hover (if the input is empty)\n    wEmpty: 'focus',\n\n    /* Controls leading zero behavior\n     * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * lZero: \"deny\", - allows only one leading zero on values less than one\n     * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     */\n    lZero: 'allow',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value\n     */\n    aForm: true,\n\n    /* Determine if the select all keyboard command will select\n     * the complete input text or only the input numeric value\n     * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n     */\n    sNumber: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {anDefault: \"\"}\n     * value=1234.56 {anDefault: '1234.56'}\n     */\n    anDefault: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     */\n    unSetOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null => nnnn.nn or -nnnn.nn default\n     * \",\"  => nnnn,nn or -nnnn,nn can also be \"-,\"\n     * \".-\" => nnnn.nn or nnnn.nn-\n     * \",-\" => nnnn,nn or nnnn,nn-\n     */\n    localeOutput: null,\n\n    /* Error handling function\n     * true => all errors are thrown - helpful in site development\n     * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n     */\n    debug: false\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224\n};\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the text given as a parameter is valid.\n     *\n     * @param text\n     * @returns {boolean}\n     */\n    function isValidPasteText(text) {\n        return text !== '' && !isNaN(text);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param text\n     * @param holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    function hasDecimals(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        return !isUndefined(decimalPart);\n    }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     * Return `null` otherwise.\n     *\n     * @param {string} str\n     * @returns {null|int}\n     */\n    function decimalPlaces(str) {\n        var _str$split3 = str.split('.'),\n            _str$split4 = _slicedToArray(_str$split3, 2),\n            decimalPart = _str$split4[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return null;\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function to handle errors messages\n     */\n    function throwError(message) {\n        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (debug) {\n            throw new Error(message);\n        }\n    }\n\n    /**\n     * Function to handle warning messages\n     */\n    function warning(message) {\n        var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (suppressWarnings) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * run callbacks in parameters if any\n     * any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the decimal length from the vMin vMax settings\n     */\n    function decLength(vMin, vMax) {\n        var vMaxLength = 0;\n        var vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\n     * Preparing user defined options for further usage\n     * merge them with defaults appropriately\n     */\n    function autoCode($this, settings) {\n        runCallbacks($this, settings);\n        var vMax = settings.vMax.toString().split('.');\n        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n        settings.aNeg = settings.vMin < 0 ? '-' : '';\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n\n        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        return settings;\n    }\n\n    /**\n     * strip all unwanted characters and leave only a number alert\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * places or removes brackets on negative values\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"localeOutput\" option definition for more details.\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale)) {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case '.-':\n                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given localeOutput [' + locale + '] option is not recognized.', true);\n        }\n\n        return result;\n    }\n\n    /**\n     * prepare number string to be converted to real number\n     */\n    function fixNumber(s, aDec, aNeg) {\n        if (aDec && aDec !== '.') {\n            s = s.replace(aDec, '.');\n        }\n        if (aNeg && aNeg !== '-') {\n            s = s.replace(aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\n     * prepare real number to be converted to our format\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg && settings.aNeg !== '-') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec && settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\n     * private function to check for empty value\n     */\n    function checkEmpty(iv, settings, signOnEmpty) {\n        if (iv === '' || iv === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? iv + settings.aSign + settings.aSuffix : settings.aSign + iv + settings.aSuffix;\n            }\n            return iv;\n        }\n\n        return null;\n    }\n\n    /**\n     * private function that formats our number\n     */\n    function autoGroup(iv, settings) {\n        if (settings.strip) {\n            iv = autoStrip(iv, settings);\n        }\n        if (settings.trailingNegative && !contains(iv, '-')) {\n            iv = '-' + iv;\n        }\n        var empty = checkEmpty(iv, settings, true);\n        var isNeg = contains(iv, '-');\n        if (isNeg) {\n            iv = iv.replace('-', '');\n        }\n        if (empty !== null) {\n            return empty;\n        }\n        var digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n\n        var _iv$split = iv.split(settings.aDec),\n            _iv$split2 = _slicedToArray(_iv$split, 2),\n            integerPart = _iv$split2[0],\n            decimalPart = _iv$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _iv$split3 = iv.split(settings.altDec);\n\n            var _iv$split4 = _slicedToArray(_iv$split3, 2);\n\n            integerPart = _iv$split4[0];\n            decimalPart = _iv$split4[1];\n        }\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            iv = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            iv = integerPart;\n        }\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                iv = settings.aNeg + settings.aSign + iv;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                iv = settings.aSign + settings.aNeg + iv;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                iv = settings.aSign + iv + settings.aNeg;\n            }\n            if (!isNeg) {\n                iv = settings.aSign + iv;\n            }\n        }\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                iv = iv + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                iv = iv + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                iv = settings.aNeg + iv + settings.aSign;\n            }\n            if (!isNeg) {\n                iv = iv + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || iv.charAt(0) === '-')) {\n            iv = negativeBracket(iv, settings);\n        }\n        settings.trailingNegative = false;\n\n        return iv + settings.aSuffix;\n    }\n\n    /**\n     * Truncate not needed zeros\n     */\n    function truncateZeros(ivRounded, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                // Prevents padding - removes trailing zeros to the first significant digit\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when mDec equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // removes access zeros to the mDec length when aPad is set true\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        ivRounded = ivRounded.replace(regex, '$1');\n        if (rDec === 0) {\n            ivRounded = ivRounded.replace(/\\.$/, '');\n        }\n\n        return ivRounded;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     */\n    function autoRound(iv, settings) {\n        // value to string\n        iv = iv === '' ? '0' : iv.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    iv = (Math.round(iv * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    iv = (Math.ceil(iv * 20) / 20).toString();\n                    break;\n                default:\n                    iv = (Math.floor(iv * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(iv, '.')) {\n                result = iv + '.00';\n            } else if (iv.length - iv.indexOf('.') < 3) {\n                result = iv + '0';\n            } else {\n                result = iv;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        // sets the truncate zero method\n        if (settings.aPad) {\n            rDec = settings.mDec;\n        } else {\n            rDec = 0;\n        }\n\n        // Checks if the iv (input Value) is a negative value\n        if (iv.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            iv = iv.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!iv.match(/^\\d/)) {\n            iv = '0' + iv;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(iv) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(iv) > 0 && settings.lZero !== 'keep' || iv.length > 0 && settings.lZero === 'allow') {\n            iv = iv.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = iv.lastIndexOf('.');\n\n        // Virtual decimal position\n        var vdPos = dPos === -1 ? iv.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = iv.length - 1 - vdPos;\n\n        if (cDec <= settings.mDec) {\n            // Check if we need to pad with zeros\n            ivRounded = iv;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        var tRound = Number(iv.charAt(rLength + 1));\n        var odd = iv.charAt(rLength) === '.' ? iv.charAt(rLength - 1) % 2 : iv.charAt(rLength) % 2;\n        var ivArray = iv.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.mRound === 'S' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        tRound > 5 && settings.mRound === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {string} paste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * checking that number satisfy format conditions\n     * and lays between settings.vMin and settings.vMax\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        if (typeof obj === 'string' || obj instanceof String) {\n            obj = obj.replace(/\\[/g, '\\\\[').replace(/]/g, '\\\\]');\n            obj = '#' + obj.replace(/(:|\\.)/g, '\\\\$1');\n            // possible modification to replace the above 2 lines\n            // obj = '#' + obj.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * function to attach data to the element\n     * and imitate the holder\n     */\n    function getHolder($that, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (isUndefined(holder) && settings || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     */\n    function keepOriginalSettings(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n        settings.oSuffix = settings.aSuffix;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init: function init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n        setSelection: function setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n        setPosition: function setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n        getBeforeAfter: function getBeforeAfter() {\n            var value = this.value;\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n        getBeforeAfterStriped: function getBeforeAfterStriped() {\n            var settingsClone = this.settingsClone;\n\n            var _getBeforeAfter = this.getBeforeAfter(),\n                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n                left = _getBeforeAfter2[0],\n                right = _getBeforeAfter2[1];\n\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = right === '-' ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n\n        /**\n         * strip parts from excess characters and leading zeroes\n         */\n        normalizeParts: function normalizeParts(left, right) {\n            var settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * set part of number to value keeping position of cursor\n         */\n        setValueParts: function setValueParts(left, right, advent) {\n            var settingsClone = this.settingsClone;\n            var parts = this.normalizeParts(left, right);\n\n            var _autoCheck = autoCheck(this.newValue, settingsClone),\n                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                minTest = _autoCheck2[0],\n                maxTest = _autoCheck2[1];\n\n            var position = parts[0].length;\n            this.newValue = parts.join('');\n\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n\n        /**\n         * helper function for expandSelectionOnSign\n         * returns sign position of a formatted value\n         */\n        signPosition: function signPosition() {\n            var settingsClone = this.settingsClone;\n            var aSign = settingsClone.aSign;\n            var that = this.that;\n\n            if (aSign) {\n                var aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                var valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n\n        /**\n         * expands selection to cover whole sign\n         * prevents partial deletion/copying/overwriting of a sign\n         */\n        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n            var signPosition = this.signPosition();\n            var selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n\n        /**\n         * try to strip pasted value to digits\n         */\n        checkPaste: function checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getBeforeAfter3 = this.getBeforeAfter(),\n                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n                    left = _getBeforeAfter4[0],\n                    right = _getBeforeAfter4[1];\n\n                // try to strip pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n\n        /**\n         * process pasting, cursor moving and skipping of not interesting keys\n         * if returns true, further processing is not performed\n         */\n        skipAlways: function skipAlways(e) {\n            var kdCode = this.kdCode;\n            var which = this.which;\n            var ctrlKey = this.ctrlKey;\n            var cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            var shiftKey = this.shiftKey;\n            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    var valueLen = this.that.value.length;\n                    var aSignLen = this.settings.aSign.length;\n                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                    var aSuffixLen = this.settings.aSuffix.length;\n                    var pSign = this.settings.pSign;\n                    var pNeg = this.settings.pNeg;\n\n                    var start = void 0;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                    }\n\n                    var end = void 0;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default:\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                var aSep = this.settingsClone.aSep;\n                var aDec = this.settingsClone.aDec;\n                var startJump = this.selection.start;\n                var value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n\n        /**\n         * process deletion of characters when the minus sign is to the right of the numeric characters\n         */\n        processTrailing: function processTrailing(_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                left = _ref2[0],\n                right = _ref2[1];\n\n            var settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '');\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * process deletion of characters\n         * returns true if processing performed\n         */\n        processAlways: function processAlways() {\n            var settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\n                    left = _getBeforeAfterStripe2[0];\n                    right = _getBeforeAfterStripe2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing = this.processTrailing([left, right]);\n\n                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\n                        left = _processTrailing2[0];\n                        right = _processTrailing2[1];\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\n                    left = _getBeforeAfterStripe4[0];\n                    right = _getBeforeAfterStripe4[1];\n\n                    this.setValueParts(left, right);\n                }\n\n                return true;\n            }\n\n            return false;\n        },\n\n\n        /**\n         * process insertion of characters\n         * returns true if processing performed\n         */\n        processKeypress: function processKeypress() {\n            var settingsClone = this.settingsClone;\n            var cCode = String.fromCharCode(this.which);\n\n            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n                left = _getBeforeAfterStripe6[0],\n                right = _getBeforeAfterStripe6[1];\n\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n\n        /**\n         * formatting of just processed value with keeping of cursor position\n         */\n        formatQuick: function formatQuick(e) {\n            var _this = this;\n\n            var settingsClone = this.settingsClone;\n            var leftLength = this.value;\n            var kuCode = e.keyCode;\n\n            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n                left = _getBeforeAfterStripe8[0];\n\n            // no grouping separator and no currency sign\n\n\n            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                var _leftLength$split = leftLength.split(settingsClone.aDec),\n                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                    subParts = _leftLength$split2[0];\n\n                var nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            var value = autoGroup(this.value, this.settingsClone);\n            var position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        (function () {\n                            var signParts = settingsClone.aSign.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            $.each(signParts, function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = Boolean(e.type === 'keydown');\n                        })();\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        }\n    };\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @returns {*}\n     * @private\n     */\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet($(that));\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('get', settings.localeOutput).toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('get', settings.localeOutput).toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onFocusIn($this, holder) {\n        $this.on('focusin.autoNumeric', function () {\n            holder = getHolder($this);\n            var $settings = holder.settingsClone;\n            $settings.onOff = true;\n\n            if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                $this.val(negativeBracket($this.val(), $settings));\n            }\n\n            var result = void 0;\n            if ($settings.eDec) {\n                $settings.mDec = $settings.eDec;\n                $this.autoNumeric('set', $settings.rawValue);\n            } else if ($settings.scaleDivisor) {\n                $settings.mDec = $settings.oDec;\n                $this.autoNumeric('set', $settings.rawValue);\n            } else if ($settings.nSep) {\n                $settings.aSep = '';\n                $settings.aSign = '';\n                $settings.aSuffix = '';\n                $this.autoNumeric('set', $settings.rawValue);\n            } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                $this.autoNumeric('set', result);\n            }\n\n            holder.inVal = $this.val();\n            holder.lastVal = holder.inVal;\n            var onEmpty = checkEmpty(holder.inVal, $settings, true);\n            if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n                $this.val(onEmpty);\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'keydown' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onKeydown($this, holder) {\n        $this.on('keydown.autoNumeric', function (e) {\n            holder = getHolder($this);\n            if (holder.that.readOnly) {\n                holder.processed = true;\n\n                return true;\n            }\n            /* // The code below allows the \"enter\" keydown to throw a change() event\n             if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\n             $this.change();\n             holder.inVal = $this.val();\n             } */\n            holder.init(e);\n            if (holder.skipAlways(e)) {\n                holder.processed = true;\n\n                return true;\n            }\n            if (holder.processAlways()) {\n                holder.processed = true;\n                holder.formatQuick(e);\n                var currentValue = $this.val();\n                if (currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                    // throws input event in deletion character\n                    $this.trigger('input');\n                }\n                holder.lastVal = currentValue;\n                holder.settingsClone.throwInput = true;\n                e.preventDefault();\n\n                return false;\n            }\n            holder.formatted = false;\n\n            return true;\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'keypress' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onKeypress($this, holder) {\n        $this.on('keypress.autoNumeric', function (e) {\n            // Firefox fix for Shift && insert paste event\n            if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                return;\n            }\n            holder = getHolder($this);\n            var processed = holder.processed;\n            holder.init(e);\n\n            if (holder.skipAlways(e)) {\n                return true;\n            }\n\n            if (processed) {\n                e.preventDefault();\n\n                return false;\n            }\n\n            if (holder.processAlways() || holder.processKeypress()) {\n                holder.formatQuick(e);\n                var currentValue = $this.val();\n                if (currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                    // throws input event on adding character\n                    $this.trigger('input');\n                }\n                holder.lastVal = currentValue;\n                holder.settingsClone.throwInput = true;\n                e.preventDefault();\n\n                return;\n            }\n            holder.formatted = false;\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'keyup' events\n     *\n     * @param $this\n     * @param holder\n     * @param settings\n     * @returns {*}\n     */\n    function onKeyup($this, holder, settings) {\n        $this.on('keyup.autoNumeric', function (e) {\n            holder = getHolder($this);\n            holder.init(e);\n            var skip = holder.skipAlways(e);\n            var tab = holder.kdCode;\n            holder.kdCode = 0;\n            delete holder.valuePartsBeforePaste;\n\n            // added to properly place the caret when only the currency sign is present\n            if ($this[0].value === holder.settingsClone.aSign) {\n                if (holder.settingsClone.pSign === 's') {\n                    setElementSelection(this, 0, 0);\n                } else {\n                    setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                }\n            } else if (tab === keyCode.Tab) {\n                setElementSelection(this, 0, $this.val().length);\n            }\n\n            if ($this[0].value === holder.settingsClone.aSuffix) {\n                setElementSelection(this, 0, 0);\n            }\n\n            if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                setElementSelection(this, 0, 0);\n            }\n\n            // saves the extended decimal to preserve the data when navigating away from the page\n            if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                autoSave($this, settings, 'set');\n            }\n            if (skip) {\n                return true;\n            }\n            if (this.value === '') {\n                return true;\n            }\n            if (!holder.formatted) {\n                holder.formatQuick(e);\n            }\n        });\n        return holder;\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onFocusOut($this, holder) {\n        $this.on('focusout.autoNumeric', function () {\n            holder = getHolder($this);\n            var value = $this.val();\n            var origValue = value;\n            var $settings = holder.settingsClone;\n            $settings.onOff = false;\n            if ($settings.aStor) {\n                autoSave($this, $settings, 'set');\n            }\n\n            if ($settings.nSep === true) {\n                $settings.aSep = $settings.oSep;\n                $settings.aSign = $settings.oSign;\n                $settings.aSuffix = $settings.oSuffix;\n            }\n\n            if ($settings.eDec !== null) {\n                $settings.mDec = $settings.oDec;\n                $settings.aPad = $settings.oPad;\n                $settings.nBracket = $settings.oBracket;\n            }\n\n            value = autoStrip(value, $settings);\n            if (value !== '') {\n                if ($settings.trailingNegative) {\n                    value = '-' + value;\n                    $settings.trailingNegative = false;\n                }\n\n                var _autoCheck3 = autoCheck(value, $settings),\n                    _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                    minTest = _autoCheck4[0],\n                    maxTest = _autoCheck4[1];\n\n                if (checkEmpty(value, $settings) === null && minTest && maxTest) {\n                    value = fixNumber(value, $settings.aDec, $settings.aNeg);\n                    $settings.rawValue = value;\n\n                    if ($settings.scaleDivisor) {\n                        value = value / $settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    $settings.mDec = $settings.scaleDivisor && $settings.scaleDecimal ? +$settings.scaleDecimal : $settings.mDec;\n                    value = autoRound(value, $settings);\n                    value = presentNumber(value, $settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = $settings.rawValue;\n                }\n            } else {\n                if ($settings.wEmpty === 'zero') {\n                    $settings.rawValue = '0';\n                    value = autoRound('0', $settings);\n                } else {\n                    $settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, $settings, false);\n            if (groupedValue === null) {\n                groupedValue = autoGroup(value, $settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = $settings.scaleSymbol ? groupedValue + $settings.scaleSymbol : groupedValue;\n                $this.val(groupedValue);\n            }\n\n            if (groupedValue !== holder.inVal) {\n                $this.change();\n                delete holder.inVal;\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onPaste($this, holder) {\n        $this.on('paste', function (e) {\n            //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n            e.preventDefault();\n            holder = getHolder($this);\n\n            var oldRawValue = $this.autoNumeric('get');\n            var currentValue = this.value || '';\n            var selectionStart = this.selectionStart || 0;\n            var selectionEnd = this.selectionEnd || 0;\n            var prefix = currentValue.substring(0, selectionStart);\n            var suffix = currentValue.substring(selectionEnd, currentValue.length);\n            var pastedText = preparePastedText(e.originalEvent.clipboardData.getData('text/plain').holder);\n\n            if (isValidPasteText(pastedText)) {\n                var newValue = preparePastedText(prefix + Number(pastedText).valueOf() + suffix, holder);\n\n                if (isValidPasteText(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                    $this.autoNumeric('set', newValue);\n                    $this.trigger('input');\n                }\n            } else {\n                this.selectionStart = selectionEnd;\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            holder = getHolder($this);\n\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unSetOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param $this\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\n     * Routine to format the default value on page load\n     *\n     * @param settings\n     * @param $input\n     * @param $this\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.aForm`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `anDefault` altogether.\n             */\n            if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                var testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                    $this.autoNumeric('set', testedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.', false);\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                    if (settings.eDec !== null && settings.aStor || settings.scaleDivisor && settings.aStor) {\n                        settings.rawValue = autoSave($this, settings, 'get');\n                    }\n\n                    // If the eDec value should NOT be saved in sessionStorage\n                    if (!settings.aStor) {\n                        var toStrip = void 0;\n\n                        if (settings.nBracket !== null && settings.aNeg !== '') {\n                            settings.onOff = true;\n                            toStrip = negativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.wEmpty) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.aSign);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.anDefault !== null) {\n                if (settings.anDefault === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     *\n     * @param options\n     * @param $this\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this) {\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n            // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n            var tagData = $this.data();\n\n            settings = $.extend({}, defaultSettings, tagData, options, {\n                onOff: false,\n                runOnce: false,\n                rawValue: '',\n                trailingNegative: false,\n                caretFix: false,\n                throwInput: true,\n                strip: true,\n                tagList: allowedTagList\n            });\n\n            // Modify the user settings to make them 'exploitable'\n            $.each(settings, function (key, value) {\n                // Convert the string 'true' and 'false' to real Boolean\n                if (value === 'true' || value === 'false') {\n                    settings[key] = Boolean(value === 'true');\n                }\n\n                // Convert numbers in options to strings\n                //TODO if a value is of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n                if (typeof value === 'number' && key !== 'aScale') {\n                    settings[key] = value.toString();\n                }\n            });\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // original settings saved for use when eDec, scaleDivisor & nSep options are being used\n                keepOriginalSettings(settings);\n                var holder = getHolder($this, settings);\n\n                //TODO Shouldn't the next line be in the `getInitialSettings()` function?\n                settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n                if (settings.runOnce === false && settings.aForm) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    holder = onFocusIn($this, holder);\n                    holder = onFocusOut($this, holder);\n                    holder = onKeydown($this, holder);\n                    holder = onKeypress($this, holder);\n                    holder = onKeyup($this, holder, settings);\n                    holder = onPaste($this, holder);\n                    onSubmit($this, holder);\n                }\n            });\n        },\n\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings\n         * It can be called multiple times if needed\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method', true);\n                }\n                var strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n\n                if (settings.scaleDivisor) {\n                    settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                }\n                keepOriginalSettings(settings);\n                getHolder($this, settings, true);\n\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character', settings.debug);\n                }\n                $this.data('autoNumeric', settings);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         */\n        set: function set(valueIn) {\n            return $(this).each(function () {\n                if (valueIn === null || isUndefined(valueIn)) {\n                    return;\n                }\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = valueIn.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method', true);\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    throwError('The value \"' + value + '\" being \"set\" is not numeric and has caused a error to be thrown', settings.debug);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.eDec || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                            }\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n                        if (settings.aStor && (settings.eDec || settings.scaleDivisor)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n                        throwError('The value [' + attemptedValue + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings for this element', settings.debug);\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n                if ($input) {\n                    return $this.val(value);\n                }\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('get'));\n                }\n            });\n        },\n\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * method to get the unformatted that accepts up to one parameter\n         * $(someSelector).autoNumeric('get'); no parameter supported\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        //TODO Create a `get()` method that always return the raw value, no matter what `localeOutput` is. Create a `getWithLocale()` method that behave like the current `get` method, which means that can sometimes return a number, or a string. Doing so will remove uncertainty for developers.\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = autoGet($(this));\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method', true);\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric', settings.debug);\n            }\n\n            if (settings.eDec || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n                value = fixNumber(value, settings.aDec, settings.aNeg);\n            }\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n\n            value = toLocale(value, settings.localeOutput);\n\n            // returned Numeric String\n            //TODO Shouldn't we return `Number(value)` since the goal of `get` is to get the raw javascript value? -> that could depend on `localeOutput`\n            return value;\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n         */\n        getSettings: function getSettings() {\n            var $this = autoGet($(this));\n\n            return $this.eq(0).data('autoNumeric');\n        }\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric', true);\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @return {object}\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * public function that allows formatting without an element trigger\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-';\n        }\n\n        if (settings.mDec === null) {\n            var vMax = settings.vMax.toString().split('.');\n            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings', settings.debug);\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\n     * public function that allows unformatting without an element\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        value = toLocale(value, settings.localeOutput);\n\n        return Number(value); //FIXME `value` here could be a string (depending on `localeOutput`), so we should only cast it to a Number when needed\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var debug = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.', debug);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.aSep, [',', '.', ' ', ''])) {\n            throwError('The thousand separator character option \\'aSep\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.aSep + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.nSep) && !isBoolean(options.nSep)) {\n            throwError('The \\'nSep\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.nSep + '] given.', debug);\n        }\n\n        if (!testPositiveInteger.test(options.dGroup)) {\n            // isNaN(parseInt(options.dGroup)) //DEBUG\n            throwError('The digital grouping for thousand separator option \\'dGroup\\' is invalid ; it should be a positive integer, [' + options.dGroup + '] given.', debug);\n        }\n\n        if (!isInArray(options.aDec, [',', '.'])) {\n            throwError('The decimal separator character option \\'aDec\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.aDec + '] given.', debug);\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.aDec === options.aSep) {\n            throwError('autoNumeric will not function properly when the decimal character \\'aDec\\' [' + options.aDec + '] and the thousand separator \\'aSep\\' [' + options.aSep + '] are the same character.', debug);\n        }\n\n        if (!isNull(options.altDec) && !isString(options.altDec)) {\n            throwError('The alternate decimal separator character option \\'altDec\\' is invalid ; it should be a string, [' + options.altDec + '] given.', debug);\n        }\n\n        if (options.aSign !== '' && !isString(options.aSign)) {\n            throwError('The currency symbol option \\'aSign\\' is invalid ; it should be a string, [' + options.aSign + '] given.', debug);\n        }\n\n        if (!isInArray(options.pSign, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'pSign\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.pSign + '] given.', debug);\n        }\n\n        if (!isInArray(options.pNeg, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'pNeg\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.pNeg + '] given.', debug);\n        }\n\n        if (!isString(options.aSuffix) || options.aSuffix !== '' && (contains(options.aSuffix, '-') || testNumericalCharacters.test(options.aSuffix))) {\n            throwError('The additional suffix option \\'aSuffix\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.aSuffix + '] given.', debug);\n        }\n\n        if (!isNull(options.oLimits) && !isInArray(options.oLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'oLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.oLimits + '] given.', debug);\n        }\n\n        if (!isString(options.vMax) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMax)) {\n            throwError('The maximum possible value option \\'vMax\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMax + '] given.', debug);\n        }\n\n        if (!isString(options.vMin) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMin)) {\n            throwError('The minimum possible value option \\'vMin\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMin + '] given.', debug);\n        }\n\n        if (parseFloat(options.vMin) > parseFloat(options.vMax)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'vMin\\' [' + options.vMin + '] should be smaller than \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.mDec) && (!isString(options.mDec) || !testPositiveInteger.test(options.mDec))) {\n            throwError('The maximum number of decimal places option \\'mDec\\' is invalid ; it should be a positive integer, [' + options.mDec + '] given.', debug);\n        }\n\n        if (!options.aPad && !isNull(options.mDec)) {\n            warning('Setting \\'aPad\\' to [false] will override the current \\'mDec\\' setting [' + options.mDec + '].', debug);\n        }\n\n        // Write a warning message in the console if the number of decimal in vMin/vMax is overridden by mDec (and not if mDec is equal to the number of decimal used in vMin/vMax)\n        var dpVMin = decimalPlaces(options.vMin);\n        var dpVMax = decimalPlaces(options.vMax);\n        dpVMin = isNull(dpVMin) ? 0 : dpVMin;\n        dpVMax = isNull(dpVMax) ? 0 : dpVMax;\n        var vMinMaxDecimalPlaces = Math.max(dpVMin, dpVMax);\n        if (!isNull(options.mDec) && (hasDecimals(options.vMin) || hasDecimals(options.vMax)) && vMinMaxDecimalPlaces !== Number(options.mDec)) {\n            warning('Setting \\'mDec\\' to [' + options.mDec + '] will override the decimals declared in \\'vMin\\' [' + options.vMin + '] and \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.eDec) && (!isString(options.eDec) || !testPositiveInteger.test(options.eDec))) {\n            throwError('The number of expanded decimal places option \\'eDec\\' is invalid ; it should be a positive integer, [' + options.eDec + '] given.', debug);\n        }\n\n        // Checks if the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n        if (!isNull(options.eDec) && !isNull(options.mDec) && Number(options.mDec) < Number(options.eDec)) {\n            throwError('autoNumeric will not function properly when the extended decimal places \\'eDec\\' [' + options.eDec + '] is greater than the \\'mDec\\' [' + options.mDec + '] value.', debug);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.', debug);\n        }\n\n        if (!isNull(options.scaleDecimal) && !testPositiveInteger.test(options.scaleDecimal)) {\n            throwError('The scale number of decimals option \\'scaleDecimal\\' is invalid ; it should be a positive integer, [' + options.scaleDecimal + '] given.', debug);\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aStor) && !isBoolean(options.aStor)) {\n            throwError('The save to session storage option \\'aStor\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aStor + '] given.', debug);\n        }\n\n        if (!isInArray(options.mRound, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'mRound\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.mRound + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aPad) && !isBoolean(options.aPad)) {\n            throwError('The control decimal padding option \\'aPad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aPad + '] given.', debug);\n        }\n\n        if (!isNull(options.nBracket) && !isInArray(options.nBracket, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'nBracket\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.nBracket + '] given.', debug);\n        }\n\n        if (!isInArray(options.wEmpty, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'wEmpty\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.wEmpty + '] given.', debug);\n        }\n\n        if (!isInArray(options.lZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'lZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.lZero + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aForm) && !isBoolean(options.aForm)) {\n            throwError('The format on initialization option \\'aForm\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aForm + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.sNumber) && !isBoolean(options.sNumber)) {\n            throwError('The select number only option \\'sNumber\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.sNumber + '] given.', debug);\n        }\n\n        if (!isNull(options.anDefault) && options.anDefault !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.anDefault)) {\n            throwError('The unformatted default value option \\'anDefault\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.anDefault + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.unSetOnSubmit) && !isBoolean(options.unSetOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unSetOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unSetOnSubmit + '] given.', debug);\n        }\n\n        if (!isNull(options.localeOutput) && !isInArray(options.localeOutput, ['.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'localeOutput\\' is invalid ; it should either be empty, \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.localeOutput + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.debug) && !isBoolean(options.debug)) {\n            throwError('The debug option \\'debug\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.debug + '] given.', debug);\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event.\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {CustomEvent}\n     */\n    function createCustomEvent(eventName, detail) {\n        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\n     * Create a custom event and immediately broadcast it.\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {boolean}\n     */\n    function sendCustomEvent(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImFsbG93ZWRUYWdMaXN0IiwiZGVmYXVsdFNldHRpbmdzIiwiYVNlcCIsIm5TZXAiLCJkR3JvdXAiLCJhRGVjIiwiYWx0RGVjIiwiYVNpZ24iLCJwU2lnbiIsInBOZWciLCJhU3VmZml4Iiwib0xpbWl0cyIsInZNYXgiLCJ2TWluIiwibURlYyIsImVEZWMiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWwiLCJzY2FsZVN5bWJvbCIsImFTdG9yIiwibVJvdW5kIiwiYVBhZCIsIm5CcmFja2V0Iiwid0VtcHR5IiwibFplcm8iLCJhRm9ybSIsInNOdW1iZXIiLCJhbkRlZmF1bHQiLCJ1blNldE9uU3VibWl0IiwibG9jYWxlT3V0cHV0IiwiZGVidWciLCJrZXlDb2RlIiwiQmFja3NwYWNlIiwiVGFiIiwiRW50ZXIiLCJTaGlmdCIsIkN0cmwiLCJBbHQiLCJQYXVzZUJyZWFrIiwiQ2Fwc0xvY2siLCJFc2MiLCJTcGFjZSIsIlBhZ2VVcCIsIlBhZ2VEb3duIiwiRW5kIiwiSG9tZSIsIkxlZnRBcnJvdyIsIlVwQXJyb3ciLCJSaWdodEFycm93IiwiRG93bkFycm93IiwiSW5zZXJ0IiwiRGVsZXRlIiwibnVtMCIsIm51bTEiLCJudW0yIiwibnVtMyIsIm51bTQiLCJudW01IiwibnVtNiIsIm51bTciLCJudW04IiwibnVtOSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiV2luZG93cyIsIlJpZ2h0Q2xpY2siLCJudW1wYWQwIiwibnVtcGFkMSIsIm51bXBhZDIiLCJudW1wYWQzIiwibnVtcGFkNCIsIm51bXBhZDUiLCJudW1wYWQ2IiwibnVtcGFkNyIsIm51bXBhZDgiLCJudW1wYWQ5IiwiTXVsdGlwbHlOdW1wYWQiLCJQbHVzTnVtcGFkIiwiTWludXNOdW1wYWQiLCJEb3ROdW1wYWQiLCJTbGFzaE51bXBhZCIsIkYxIiwiRjIiLCJGMyIsIkY0IiwiRjUiLCJGNiIsIkY3IiwiRjgiLCJGOSIsIkYxMCIsIkYxMSIsIkYxMiIsIk51bUxvY2siLCJTY3JvbGxMb2NrIiwiTXlDb21wdXRlciIsIk15Q2FsY3VsYXRvciIsIlNlbWljb2xvbiIsIkVxdWFsIiwiQ29tbWEiLCJIeXBoZW4iLCJEb3QiLCJTbGFzaCIsIkJhY2txdW90ZSIsIkxlZnRCcmFja2V0IiwiQmFja3NsYXNoIiwiUmlnaHRCcmFja2V0IiwiUXVvdGUiLCJDb21tYW5kIiwiZmFjdG9yeSIsImRlZmluZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwid2luZG93IiwialF1ZXJ5IiwiaXNOdWxsIiwidmFsdWUiLCJpc1VuZGVmaW5lZCIsImlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSIsImlzU3RyaW5nIiwic3RyIiwiU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNUcnVlT3JGYWxzZVN0cmluZyIsImxvd2VyY2FzZVZhbHVlIiwidG9Mb3dlckNhc2UiLCJpc09iamVjdCIsInJlZmVyZW5jZSIsIkFycmF5IiwiaXNBcnJheSIsImlzRW1wdHlPYmoiLCJvYmoiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJpc1ZhbGlkUGFzdGVUZXh0IiwidGV4dCIsImlzTmFOIiwicHJlcGFyZVBhc3RlZFRleHQiLCJob2xkZXIiLCJhdXRvU3RyaXAiLCJzZXR0aW5nc0Nsb25lIiwicmVwbGFjZSIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJoYXNEZWNpbWFscyIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJkZWNpbWFsUGxhY2VzIiwibGVuZ3RoIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwibW92ZVN0YXJ0IiwiZW5kIiwic3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJzZXRFbGVtZW50U2VsZWN0aW9uIiwicmFuZ2UiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsIndhcm5pbmciLCJzdXBwcmVzc1dhcm5pbmdzIiwiY29uc29sZSIsIndhcm4iLCJydW5DYWxsYmFja3MiLCIkdGhpcyIsInNldHRpbmdzIiwiJCIsImVhY2giLCJ2YWwiLCJhdXRvTnVtZXJpYyIsImRlY0xlbmd0aCIsInZNYXhMZW5ndGgiLCJ2TWluTGVuZ3RoIiwiTWF0aCIsIm1heCIsImF1dG9Db2RlIiwiYU5lZyIsIm1JbnRQb3MiLCJtSW50TmVnIiwib0RlYyIsIk51bWJlciIsImFOZWdSZWciLCJhTmVnUmVnQXV0b1N0cmlwIiwic2tpcEZpcnN0QXV0b1N0cmlwIiwiUmVnRXhwIiwic2tpcExhc3RBdXRvU3RyaXAiLCJhbGxvd2VkIiwiYWxsb3dlZEF1dG9TdHJpcCIsIm51bVJlZ0F1dG9TdHJpcCIsInRyYWlsaW5nTmVnYXRpdmUiLCJtYXRjaCIsImpvaW4iLCJuU2lnbiIsImludGVnZXJQYXJ0IiwibW9kaWZpZWRJbnRlZ2VyUGFydCIsImNoYXJBdCIsInNsaWNlIiwib25PZmYiLCJzdHJpcFJlZyIsIm5lZ2F0aXZlQnJhY2tldCIsImZpcnN0QnJhY2tldCIsImxhc3RCcmFja2V0IiwiZnJvbUxvY2FsZSIsImxhc3RJbmRleE9mIiwidG9Mb2NhbGUiLCJsb2NhbGUiLCJyZXN1bHQiLCJmaXhOdW1iZXIiLCJwcmVzZW50TnVtYmVyIiwiY2hlY2tFbXB0eSIsIml2Iiwic2lnbk9uRW1wdHkiLCJhdXRvR3JvdXAiLCJzdHJpcCIsImVtcHR5IiwiaXNOZWciLCJkaWdpdGFsR3JvdXAiLCJ0ZXN0Iiwic3Vic3RyaW5nIiwicmF3VmFsdWUiLCJ0cnVuY2F0ZVplcm9zIiwiaXZSb3VuZGVkIiwickRlYyIsInJlZ2V4IiwiYXV0b1JvdW5kIiwicm91bmQiLCJjZWlsIiwiZmxvb3IiLCJkUG9zIiwidmRQb3MiLCJjRGVjIiwiemVyb3MiLCJyTGVuZ3RoIiwidFJvdW5kIiwib2RkIiwiaXZBcnJheSIsInRydW5jYXRlRGVjaW1hbCIsInBhc3RlIiwibW9kaWZpZWREZWNpbWFsUGFydCIsInBhcnNlU3RyIiwibkwiLCJzZWFyY2giLCJ0ZXN0TWluTWF4IiwieGMiLCJ5YyIsInhOZWciLCJhdXRvQ2hlY2siLCJtaW5QYXJzZSIsIm1heFBhcnNlIiwidmFsUGFyc2UiLCJhdXRvR2V0IiwiZ2V0SG9sZGVyIiwiJHRoYXQiLCJ1cGRhdGUiLCJkYXRhIiwiQXV0b051bWVyaWNIb2xkZXIiLCJnZXQiLCJrZWVwT3JpZ2luYWxTZXR0aW5ncyIsIm9QYWQiLCJvQnJhY2tldCIsIm9TZXAiLCJvU2lnbiIsIm9TdWZmaXgiLCJyZWFkQ29va2llIiwibmFtZSIsIm5hbWVFUSIsImNhIiwiY29va2llIiwic3RvcmFnZVRlc3QiLCJtb2QiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiYXV0b1NhdmUiLCJ0b0RvIiwic3RvcmVkTmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkIiwiZGF0ZSIsImV4cGlyZXMiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1VUQ1N0cmluZyIsImdldEl0ZW0iLCJmb3JtYXR0ZWQiLCJpbml0IiwiY3RybEtleSIsImNtZEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsInR5cGUiLCJrZENvZGUiLCJ3aGljaCIsInByb2Nlc3NlZCIsInNldFNlbGVjdGlvbiIsInNldFJlYWwiLCJtaW4iLCJzZXRQb3NpdGlvbiIsInBvcyIsImdldEJlZm9yZUFmdGVyIiwibGVmdCIsInJpZ2h0IiwiZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkIiwibm9ybWFsaXplUGFydHMiLCJuZXdWYWx1ZSIsInNldFZhbHVlUGFydHMiLCJhZHZlbnQiLCJwYXJ0cyIsIm1pblRlc3QiLCJtYXhUZXN0IiwidGVzdFZhbHVlIiwidHJpZ2dlciIsInNpZ25Qb3NpdGlvbiIsImFTaWduTGVuIiwiaGFzTmVnIiwidmFsdWVMZW4iLCJleHBhbmRTZWxlY3Rpb25PblNpZ24iLCJjaGVja1Bhc3RlIiwidmFsdWVQYXJ0c0JlZm9yZVBhc3RlIiwib2xkUGFydHMiLCJtb2RpZmllZExlZnRQYXJ0Iiwic3Vic3RyIiwic2tpcEFsd2F5cyIsInByZXZlbnREZWZhdWx0IiwibmVnTGVuIiwiYVN1ZmZpeExlbiIsInN0YXJ0SnVtcCIsInByb2Nlc3NUcmFpbGluZyIsImNhcmV0Rml4IiwiQm9vbGVhbiIsInByb2Nlc3NBbHdheXMiLCJ0aHJvd0lucHV0IiwicHJvY2Vzc0tleXByZXNzIiwiY0NvZGUiLCJmcm9tQ2hhckNvZGUiLCJmb3JtYXRRdWljayIsImxlZnRMZW5ndGgiLCJrdUNvZGUiLCJzdWJQYXJ0cyIsImxlZnRBciIsInNoaWZ0IiwicHVzaCIsInNpZ25QYXJ0cyIsImVzY2FwZUNociIsImVzY2FwZWRQYXJ0cyIsIm1pbmlQYXJ0cyIsImxlZnRSZWciLCJuZXdMZWZ0IiwiX2dldFN0cmluZ09yQXJyYXkiLCJnZXRBcnJheUJlaGF2aW9yIiwiZm9ybUluZGV4IiwiaW5kZXgiLCJhbGxGb3JtRWxlbWVudHMiLCJhaUluZGV4Iiwic2NJbmRleCIsInJTdWJtaXR0ZXJUeXBlcyIsInJTdWJtaXR0YWJsZSIsInJDaGVja2FibGVUeXBlIiwick5vbkF1dG9OdW1lcmljVHlwZXMiLCJjb3VudCIsImZpZWxkIiwibG9jYWxOYW1lIiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiZm9ybUZpZWxkcyIsInNlcmlhbGl6ZUFycmF5Iiwic2NFbGVtZW50IiwiaW5BcnJheSIsInRlc3RJbnB1dCIsInNlcmlhbGl6ZSIsImZvcm1QYXJ0cyIsImlucHV0TmFtZSIsImlucHV0VmFsdWUiLCJtb2RpZmllZElucHV0VmFsdWUiLCJvbkZvY3VzSW4iLCJvbiIsIiRzZXR0aW5ncyIsImluVmFsIiwibGFzdFZhbCIsIm9uRW1wdHkiLCJvbktleWRvd24iLCJyZWFkT25seSIsImN1cnJlbnRWYWx1ZSIsIm9uS2V5cHJlc3MiLCJvbktleXVwIiwic2tpcCIsInRhYiIsIm9uRm9jdXNPdXQiLCJvcmlnVmFsdWUiLCJncm91cGVkVmFsdWUiLCJjaGFuZ2UiLCJvblBhc3RlIiwib2xkUmF3VmFsdWUiLCJwcmVmaXgiLCJzdWZmaXgiLCJwYXN0ZWRUZXh0Iiwib3JpZ2luYWxFdmVudCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwidmFsdWVPZiIsIm9uU3VibWl0IiwiY2xvc2VzdCIsImdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlIiwiJGlucHV0IiwiaXMiLCJjdXJyZW50RWxlbWVudFRhZyIsImZvcm1hdERlZmF1bHRWYWx1ZU9uUGFnZUxvYWQiLCJzZXRWYWx1ZSIsImF0dHIiLCJ0ZXN0ZWRDdXJyZW50VmFsdWUiLCJwYXJzZUZsb2F0IiwiSW5maW5pdHkiLCJpc051bWVyaWMiLCJ0b1N0cmlwIiwidGFnTGlzdCIsImdldEluaXRpYWxTZXR0aW5ncyIsIm9wdGlvbnMiLCJ0YWdEYXRhIiwiZXh0ZW5kIiwicnVuT25jZSIsImtleSIsIm1ldGhvZHMiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJ2YWx1ZUluIiwiYXR0ZW1wdGVkVmFsdWUiLCJ1blNldCIsInJlU2V0IiwiZXEiLCJnZXRGb3JtYXR0ZWQiLCJnZXRTdHJpbmciLCJnZXRBcnJheSIsImdldFNldHRpbmdzIiwiZm4iLCJtZXRob2QiLCJhcmdzIiwiYXBwbHkiLCJkZWZhdWx0cyIsInNlbmRDdXN0b21FdmVudCIsImF1dG9VbmZvcm1hdCIsInVzZXJPcHRpb25zIiwic2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMiLCJ0ZXN0UG9zaXRpdmVJbnRlZ2VyIiwidGVzdE51bWVyaWNhbENoYXJhY3RlcnMiLCJ0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiIsInRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyIiwiZHBWTWluIiwiZHBWTWF4Iiwidk1pbk1heERlY2ltYWxQbGFjZXMiLCJpc1ZhbGlkIiwiZXJyb3IiLCJjcmVhdGVDdXN0b21FdmVudCIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkaXNwYXRjaEV2ZW50IiwiZXZlbnQiLCJwYXJhbXMiLCJldnQiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsIkV2ZW50IiwiZm9ybWF0IiwidW5Gb3JtYXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOztBQUVBO0FBQ0EsSUFBSUEsbUJBQUo7QUFDQSxJQUFJQyxxQkFBSjtBQUNBLElBQUlDLHlCQUFKO0FBQ0EsSUFBSUMsaUJBQUo7QUFDQSxJQUFJQyx5QkFBSjs7QUFFQTtBQUNBOzs7QUFHQSxJQUFNQyxpQkFBaUIsQ0FDbkIsR0FEbUIsRUFFbkIsU0FGbUIsRUFHbkIsTUFIbUIsRUFJbkIsTUFKbUIsRUFLbkIsT0FMbUIsRUFNbkIsSUFObUIsRUFPbkIsS0FQbUIsRUFRbkIsS0FSbUIsRUFTbkIsS0FUbUIsRUFVbkIsSUFWbUIsRUFXbkIsSUFYbUIsRUFZbkIsSUFabUIsRUFhbkIsSUFibUIsRUFjbkIsSUFkbUIsRUFlbkIsSUFmbUIsRUFnQm5CLElBaEJtQixFQWlCbkIsSUFqQm1CLEVBa0JuQixLQWxCbUIsRUFtQm5CLEtBbkJtQixFQW9CbkIsT0FwQm1CLEVBcUJuQixJQXJCbUIsRUFzQm5CLFFBdEJtQixFQXVCbkIsUUF2Qm1CLEVBd0JuQixHQXhCbUIsRUF5Qm5CLEdBekJtQixFQTBCbkIsR0ExQm1CLEVBMkJuQixRQTNCbUIsRUE0Qm5CLE1BNUJtQixFQTZCbkIsUUE3Qm1C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Q0FBcUIsYUFBckIsQ0FBWjtBQUNBRCxnQkFBSUUsZUFBSixDQUFvQkosS0FBcEIsRUFBMkJDLE9BQU9KLE9BQWxDLEVBQTJDSSxPQUFPSCxVQUFsRCxFQUE4REcsT0FBT04sTUFBckU7QUFDQSxtQkFBT08sR0FBUDtBQUNIOztBQUVETixvQkFBWXhVLFNBQVosR0FBd0JwQyxPQUFPcVgsS0FBUCxDQUFhalYsU0FBckM7QUFDQXBDLGVBQU80VyxXQUFQLEdBQXFCQSxXQUFyQjtBQUNILEtBZEQ7QUFlSCxDQW44RkEsQ0FBRDs7QUFxOEZBOzs7a0JBR2U7QUFDWFUsWUFBVXJnQixVQURDO0FBRVhzZ0IsY0FBVXJnQixZQUZDO0FBR1hDLHNDQUhXO0FBSVhDLHNCQUpXLEVBSUQ7QUFDVkMsc0NBTFcsRSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIGF1dG9OdW1lcmljLmpzXG4qIEBhdXRob3I6IEJvYiBLbm90aGVcbiogQGNvbnRyaWJ1dG9yczogU29rb2xvdiBZdXJhIGFuZCBvdGhlciBHaXRodWIgdXNlcnNcbiogQHZlcnNpb246IDIuMCAtIDIwMTYtMTEtMjcgVVRDIDExOjAwXG4qXG4qIENyZWF0ZWQgYnkgUm9iZXJ0IEouIEtub3RoZSBvbiAyMDA5LTA4LTA5LiBQbGVhc2UgcmVwb3J0IGFueSBidWdzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9Cb2JLbm90aGUvYXV0b051bWVyaWNcbipcbiogQ29weXJpZ2h0IChjKSAyMDA5IFJvYmVydCBKLiBLbm90aGUgaHR0cDovL3d3dy5kZWNvcnBsYW5pdC5jb20vcGx1Z2luL1xuKlxuKiBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLyogZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgZGVmaW5lICovXG5cbi8vIEZ1bmN0aW9ucyBuYW1lcyBmb3IgRVM2IGV4cG9ydHNcbmxldCBhdXRvRm9ybWF0O1xubGV0IGF1dG9VbkZvcm1hdDtcbmxldCBnZXREZWZhdWx0Q29uZmlnO1xubGV0IHZhbGlkYXRlO1xubGV0IGFyZVNldHRpbmdzVmFsaWQ7XG5cbi8vIEF1dG9OdW1lcmljIGRlZmF1bHQgc2V0dGluZ3Ncbi8qKlxuICogTGlzdCBvZiBhbGxvd2VkIHRhZyBvbiB3aGljaCBhdXRvTnVtZXJpYyBjYW4gYmUgdXNlZC5cbiAqL1xuY29uc3QgYWxsb3dlZFRhZ0xpc3QgPSBbXG4gICAgJ2InLFxuICAgICdjYXB0aW9uJyxcbiAgICAnY2l0ZScsXG4gICAgJ2NvZGUnLFxuICAgICdjb25zdCcsXG4gICAgJ2RkJyxcbiAgICAnZGVsJyxcbiAgICAnZGl2JyxcbiAgICAnZGZuJyxcbiAgICAnZHQnLFxuICAgICdlbScsXG4gICAgJ2gxJyxcbiAgICAnaDInLFxuICAgICdoMycsXG4gICAgJ2g0JyxcbiAgICAnaDUnLFxuICAgICdoNicsXG4gICAgJ2lucycsXG4gICAgJ2tkYicsXG4gICAgJ2xhYmVsJyxcbiAgICAnbGknLFxuICAgICdvcHRpb24nLFxuICAgICdvdXRwdXQnLFxuICAgICdwJyxcbiAgICAncScsXG4gICAgJ3MnLFxuICAgICdzYW1wbGUnLFxuICAgICdzcGFuJyxcbiAgICAnc3Ryb25nJyxcbiAgICAndGQnLFxuICAgICd0aCcsXG4gICAgJ3UnLFxuXTtcblxuLyoqXG4gKiBEZWZhdWx0cyBvcHRpb25zIGFyZSBwdWJsaWMgLSB0aGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgZm9sbG93aW5nOlxuICogLSBIVE1MNSBkYXRhIGF0dHJpYnV0ZXNcbiAqIC0gT3B0aW9ucyBwYXNzZWQgYnkgdGhlICdpbml0JyBvciAndXBkYXRlJyBtZXRob2RzXG4gKiAtIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcbiAqL1xuY29uc3QgZGVmYXVsdFNldHRpbmdzID0ge1xuICAgIC8qIEFsbG93ZWQgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlcnNcbiAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxuICAgICAqIGFwb3N0cm9waGUgaXMgZXNjYXBlZCA9IFwiXFxcIlwiXG4gICAgICogc3BhY2UgPSBcIiBcIlxuICAgICAqIG5vbmUgPSBcIlwiXG4gICAgICogTk9URTogZG8gbm90IHVzZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgKi9cbiAgICBhU2VwOiAnLCcsXG5cbiAgICAvKiBXaGVuIHRydWUgPT4gcmVtb3ZlcyB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yLCBjdXJyZW5jeSBzeW1ib2wgJiBzdWZmaXggXCJmb2N1c2luXCJcbiAgICAgKiBleGFtcGxlIGlmIHRoZSBpbnB1dCB2YWx1ZSBcIiQgMSw5OTkuODggc3VmZml4XCJcbiAgICAgKiBvbiBcImZvY3VzaW5cIiBpdCBiZWNvbWVzIFwiMTk5OS44OFwiIGFuZCBiYWNrIHRvIFwiJCAxLDk5OS44OCBzdWZmaXhcIiBvbiBmb2N1cyBvdXQuXG4gICAgICovXG4gICAgblNlcDogZmFsc2UsXG5cbiAgICAvKiBEaWdpdGFsIGdyb3VwaW5nIGZvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHVzZWQgaW4gRm9ybWF0XG4gICAgICogZEdyb3VwOiBcIjJcIiwgcmVzdWx0cyBpbiA5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtoc1xuICAgICAqIGRHcm91cDogXCIyc1wiLCByZXN1bHRzIGluIDk5LDk5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtocyBzY2FsZWRcbiAgICAgKiBkR3JvdXA6IFwiM1wiLCByZXN1bHRzIGluIDk5OSw5OTksOTk5IGRlZmF1bHRcbiAgICAgKiBkR3JvdXA6IFwiNFwiLCByZXN1bHRzIGluIDk5OTksOTk5OSw5OTk5IHVzZWQgaW4gc29tZSBBc2lhbiBjb3VudHJpZXNcbiAgICAgKi9cbiAgICBkR3JvdXA6ICczJyxcblxuICAgIC8qIEFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuICAgICAqIHBlcmlvZCBcImZ1bGwgc3RvcFwiID0gXCIuXCJcbiAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICovXG4gICAgYURlYzogJy4nLFxuXG4gICAgLyogQWxsb3cgdG8gZGVjbGFyZSBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIGJ5IGFEZWNcbiAgICAgKiBkZXZlbG9wZWQgZm9yIGNvdW50cmllcyB0aGUgdXNlIGEgY29tbWEgXCIsXCIgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICogYW5kIGhhdmUga2V5Ym9hcmRzXFxudW1lcmljIHBhZHMgdGhhdCBoYXZlIGEgcGVyaW9kICdmdWxsIHN0b3AnIGFzIHRoZSBkZWNpbWFsIGNoYXJhY3RlcnMgKFNwYWluIGlzIGFuIGV4YW1wbGUpXG4gICAgICovXG4gICAgYWx0RGVjOiBudWxsLFxuXG4gICAgLyogYVNpZ24gPSBhbGxvd2VkIGN1cnJlbmN5IHN5bWJvbFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGFTaWduOiBcIiRcIlxuICAgICAqIHNwYWNlIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGFTaWduOiAnJCAnXG4gICAgICogc3BhY2UgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBhU2lnbjogJyAkJ1xuICAgICAqL1xuICAgIGFTaWduOiAnJyxcblxuICAgIC8qIHBTaWduID0gcGxhY2VtZW50IG9mIGN1cnJlbmN5IHNpZ24gYXMgYSBwPXByZWZpeCBvciBzPXN1ZmZpeFxuICAgICAqIGZvciBwcmVmaXggcFNpZ246IFwicFwiIChkZWZhdWx0KVxuICAgICAqIGZvciBzdWZmaXggcFNpZ246IFwic1wiXG4gICAgICovXG4gICAgcFNpZ246ICdwJyxcblxuICAgIC8qIFBsYWNlbWVudCBvZiBuZWdhdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBhU2lnbiBvcHRpb24gbD1sZWZ0LCByPXJpZ2h0LCBwPXByZWZpeCAmIHM9c3VmZml4XG4gICAgICogLTEsMjM0LjU2ICA9PiBkZWZhdWx0IG5vIG9wdGlvbnMgcmVxdWlyZWRcbiAgICAgKiAtJDEsMjM0LjU2ID0+IHthU2lnbjogXCIkXCJ9XG4gICAgICogJC0xLDIzNC41NiA9PiB7YVNpZ246IFwiJFwiLCBwTmVnOiBcInJcIn1cbiAgICAgKiAtMSwyMzQuNTYkID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIiwgcE5lZzogXCJwXCJ9XG4gICAgICogMSwyMzQuNTYtICA9PiB7cE5lZzogXCJzXCJ9XG4gICAgICogJDEsMjM0LjU2LSA9PiB7YVNpZ246IFwiJFwiLCBwTmVnOiBcInNcIn1cbiAgICAgKiAxLDIzNC41Ni0kID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIn1cbiAgICAgKiAxLDIzNC41NiQtID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIiwgcE5lZzogXCJyXCJ9XG4gICAgICovXG4gICAgcE5lZzogJ2wnLFxuXG4gICAgLyogQWRkaXRpb25hbCBzdWZmaXhcbiAgICAgKiBNdXN0IGJlIGluIHF1b3RlcyBhU3VmZml4OiAnZ3Jvc3MnLCBhIHNwYWNlIGlzIGFsbG93ZWQgYVN1ZmZpeDogJyBkb2xsYXJzJ1xuICAgICAqIE51bWVyaWMgY2hhcmFjdGVycyBhbmQgbmVnYXRpdmUgc2lnbiBub3QgYWxsb3dlZCdcbiAgICAgKi9cbiAgICBhU3VmZml4OiAnJyxcblxuICAgIC8qIE92ZXJyaWRlIG1pbiBtYXggbGltaXRzXG4gICAgICogb0xpbWl0czogXCJjZWlsaW5nXCIgYWRoZXJlcyB0byB2TWF4IGFuZCBpZ25vcmVzIHZNaW4gc2V0dGluZ3NcbiAgICAgKiBvTGltaXRzOiBcImZsb29yXCIgYWRoZXJlcyB0byB2TWluIGFuZCBpZ25vcmVzIHZNYXggc2V0dGluZ3NcbiAgICAgKiBvTGltaXRzOiBcImlnbm9yZVwiIGlnbm9yZXMgYm90aCB2TWluICYgdk1heFxuICAgICAqL1xuICAgIG9MaW1pdHM6IG51bGwsXG5cbiAgICAvKiBNYXhpbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAqIHZhbHVlIG11c3QgYmUgbGFyZ2VyIHRoYW4gdk1pblxuICAgICAqL1xuICAgIHZNYXg6ICc5OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgIC8qIE1pbmltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XG4gICAgICogdmFsdWUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gdk1heFxuICAgICAqL1xuICAgIHZNaW46ICctOTk5OTk5OTk5OTk5OS45OScsXG5cbiAgICAvKiBNYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyA9IHVzZWQgdG8gb3ZlcnJpZGUgZGVjaW1hbCBwbGFjZXMgc2V0IGJ5IHRoZSB2TWluICYgdk1heCB2YWx1ZXNcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBleGFtcGxlIG1EZWM6IFwiM1wiLFxuICAgICAqL1xuICAgIG1EZWM6IG51bGwsXG5cbiAgICAvKiBFeHBhbmRlZCBkZWNpbWFsIHBsYWNlcyB2aXNpYmxlIHdoZW4gaW5wdXQgaGFzIGZvY3VzIC0gZXhhbXBsZTpcbiAgICAgKiB7ZURlYzogXCI1XCJ9IGFuZCB0aGUgZGVmYXVsdCAyIGRlY2ltYWwgcGxhY2VzIHdpdGggZm9jdXMgXCIxLDAwMC4xMjM0NVwiIHdpdGhvdXQgZm9jdXMgXCIxLDAwMC4xMlwiIHRoZSByZXN1bHRzIGRlcGVuZHMgb24gdGhlIHJvdW5kaW5nIG1ldGhvZCB1c2VkXG4gICAgICogdGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXG4gICAgICovXG4gICAgZURlYzogbnVsbCxcblxuICAgIC8qIFRoZSBuZXh0IHRocmVlIG9wdGlvbnMgKHNjYWxlRGl2aXNvciwgc2NhbGVEZWNpbWFsICYgc2NhbGVTeW1ib2wpIGhhbmRsZSBzY2FsaW5nIG9mIHRoZSBpbnB1dCB3aGVuIHRoZSBpbnB1dCBkb2VzIG5vdCBoYXZlIGZvY3VzXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgbm9uLXNjYWxlZCB2YWx1ZSBpcyBoZWxkIGluIGRhdGEgYW5kIGl0IGlzIGFkdmlzZWQgdGhhdCB5b3UgdXNlIHRoZSBcImFTdG9yXCIgb3B0aW9uIHRvIGVuc3VyZSByZXRhaW5pbmcgdGhlIHZhbHVlXG4gICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXG4gICAgICogRXhhbXBsZTogd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbnMgc2V0IHtzY2FsZURpdmlzb3I6ICcxMDAwJywgc2NhbGVEZWNpbWFsOiAnMScsIHNjYWxlU3ltYm9sOiAnIEsnfVxuICAgICAqIEV4YW1wbGU6IGZvY3VzaW4gdmFsdWUgXCIxLDExMS4xMVwiIGZvY3Vzb3V0IHZhbHVlIFwiMS4xIEtcIlxuICAgICAqL1xuXG4gICAgLyogVGhlIGBzY2FsZURpdmlzb3JgIGRlY2lkZXMgdGhlIG9uIGZvY3VzIHZhbHVlIGFuZCBwbGFjZXMgdGhlIHJlc3VsdCBpbiB0aGUgaW5wdXQgb24gZm9jdXNvdXRcbiAgICAgKiBFeGFtcGxlIHtzY2FsZURpdmlzb3I6ICcxMDAwJ30gb3IgPGlucHV0IGRhdGEtc2NhbGUtZGl2aXNvcj1cIjEwMDBcIj5cbiAgICAgKiBUaGUgZGl2aXNvciB2YWx1ZSAtIGRvZXMgbm90IG5lZWQgdG8gYmUgd2hvbGUgbnVtYmVyIGJ1dCBwbGVhc2UgdW5kZXJzdGFuZCB0aGF0IEphdmFzY3JpcHQgaGFzIGxpbWl0ZWQgYWNjdXJhY3kgaW4gbWF0aFxuICAgICAqIFRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBmdWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlICdoaWRkZW4nIGRlY2ltYWxzLlxuICAgICAqL1xuICAgIHNjYWxlRGl2aXNvcjogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZURlY2ltYWxgIG9wdGlvbiBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2Ugd2hlbiBub3QgaW4gZm9jdXMgLSBmb3IgdGhpcyB0byB3b3JrLCBgc2NhbGVkRGl2aXNvcmAgbXVzdCBub3QgYmUgYG51bGxgLlxuICAgICAqIFRoaXMgaXMgb3B0aW9uYWwgOyBpZiBvbWl0dGVkIHRoZSBkZWNpbWFsIHBsYWNlcyB3aWxsIGJlIHRoZSBzYW1lIHdoZW4gdGhlIGlucHV0IGhhcyB0aGUgZm9jdXMuXG4gICAgICovXG4gICAgc2NhbGVEZWNpbWFsOiBudWxsLFxuXG4gICAgLypcbiAgICAgKiBUaGUgYHNjYWxlU3ltYm9sYCBvcHRpb24gaXMgYSBzeW1ib2wgcGxhY2VkIGFzIGEgc3VmZml4IHdoZW4gbm90IGluIGZvY3VzLlxuICAgICAqIFRoaXMgaXMgb3B0aW9uYWwgdG9vLlxuICAgICAqL1xuICAgIHNjYWxlU3ltYm9sOiBudWxsLFxuXG4gICAgLyogU2V0IHRvIHRydWUgdG8gYWxsb3cgdGhlIGVEZWMgdmFsdWUgdG8gYmUgc2F2ZWQgd2l0aCBzZXNzaW9uU3RvcmFnZVxuICAgICAqIGlmIGllIDYgb3IgNyB0aGUgdmFsdWUgd2lsbCBiZSBzYXZlZCBhcyBhIHNlc3Npb24gY29va2llXG4gICAgICovXG4gICAgYVN0b3I6IGZhbHNlLFxuXG4gICAgLyogbWV0aG9kIHVzZWQgZm9yIHJvdW5kaW5nXG4gICAgICogbVJvdW5kOiBcIlNcIiwgUm91bmQtSGFsZi1VcCBTeW1tZXRyaWMgKGRlZmF1bHQpXG4gICAgICogbVJvdW5kOiBcIkFcIiwgUm91bmQtSGFsZi1VcCBBc3ltbWV0cmljXG4gICAgICogbVJvdW5kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxuICAgICAqIG1Sb3VuZDogXCJhXCIsIFJvdW5kLUhhbGYtRG93biBBc3ltbWV0cmljIChsb3dlciBjYXNlIGEpXG4gICAgICogbVJvdW5kOiBcIkJcIiwgUm91bmQtSGFsZi1FdmVuIFwiQmFua2VycyBSb3VuZGluZ1wiXG4gICAgICogbVJvdW5kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXG4gICAgICogbVJvdW5kOiBcIkRcIiwgUm91bmQgRG93biBcIlJvdW5kLVRvd2FyZC1aZXJvXCIgLSBzYW1lIGFzIHRydW5jYXRlXG4gICAgICogbVJvdW5kOiBcIkNcIiwgUm91bmQgdG8gQ2VpbGluZyBcIlRvd2FyZCBQb3NpdGl2ZSBJbmZpbml0eVwiXG4gICAgICogbVJvdW5kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxuICAgICAqIG1Sb3VuZDogXCJOMDVcIiBSb3VuZHMgdG8gdGhlIG5lYXJlc3QgLjA1ID0+IHNhbWUgYXMgXCJDSEZcIiB1c2VkIGluIDEuOVggYW5kIHN0aWxsIHZhbGlkXG4gICAgICogbVJvdW5kOiBcIlUwNVwiIFJvdW5kcyB1cCB0byBuZXh0IC4wNVxuICAgICAqIG1Sb3VuZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxuICAgICAqL1xuICAgIG1Sb3VuZDogJ1MnLFxuXG4gICAgLyogQ29udHJvbHMgZGVjaW1hbCBwYWRkaW5nXG4gICAgICogYVBhZDogdHJ1ZSAtIGFsd2F5cyBQYWQgZGVjaW1hbHMgd2l0aCB6ZXJvc1xuICAgICAqIGFQYWQ6IGZhbHNlIC0gZG9lcyBub3QgcGFkIHdpdGggemVyb3MuXG4gICAgICogTm90ZTogc2V0dGluZyBhUGFkIHRvICdmYWxzZScgd2lsbCBvdmVycmlkZSB0aGUgJ21EZWMnIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiB0aGFua3MgdG8gSm9uYXMgSm9oYW5zc29uIGZvciB0aGUgc3VnZ2VzdGlvblxuICAgICAqL1xuICAgIGFQYWQ6IHRydWUsXG5cbiAgICAvKiBBZGRzIGJyYWNrZXRzIG9uIG5lZ2F0aXZlIHZhbHVlcyAoaWUuIHRyYW5zZm9ybXMgJy0kIDk5OS45OScgdG8gJyg5OTkuOTkpJylcbiAgICAgKiBUaG9zZSBicmFja2V0cyBhcmUgdmlzaWJsZSBvbmx5IHdoZW4gdGhlIGZpZWxkIGRvZXMgTk9UIGhhdmUgdGhlIGZvY3VzLlxuICAgICAqIFRoZSBsZWZ0IGFuZCByaWdodCBzeW1ib2xzIHNob3VsZCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHNlcGFyYXRlZCBieSBhIGNvbW1hXG4gICAgICogbkJyYWNrZXQ6IG51bGwgLSAoZGVmYXVsdClcbiAgICAgKiBuQnJhY2tldDogJygsKScsIG5CcmFja2V0OiAnWyxdJywgbkJyYWNrZXQ6ICc8LD4nIG9yIG5CcmFja2V0OiAneyx9J1xuICAgICAqL1xuICAgIG5CcmFja2V0OiBudWxsLFxuXG4gICAgLyogRGlzcGxheWVkIG9uIGVtcHR5IHN0cmluZyBcIlwiXG4gICAgICogd0VtcHR5OiBcImZvY3VzXCIgLSAoZGVmYXVsdCkgY3VycmVuY3kgc2lnbiBkaXNwbGF5ZWQgYW5kIHRoZSBpbnB1dCByZWNlaXZlcyBmb2N1c1xuICAgICAqIHdFbXB0eTogXCJwcmVzc1wiIC0gY3VycmVuY3kgc2lnbiBkaXNwbGF5cyBvbiBhbnkga2V5IGJlaW5nIHByZXNzZWRcbiAgICAgKiB3RW1wdHk6IFwiYWx3YXlzXCIgLSBhbHdheXMgZGlzcGxheXMgdGhlIGN1cnJlbmN5IHNpZ24gb25seVxuICAgICAqIHdFbXB0eTogXCJ6ZXJvXCIgLSBpZiB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlIG9uIGZvY3VzIG91dCBkaXNwbGF5cyBhIHplcm8gXCJyb3VuZGVkXCIgd2l0aCBvciB3aXRoIGEgY3VycmVuY3kgc2lnblxuICAgICAqL1xuICAgIC8vVE9ETyBBZGQgYW4gb3B0aW9uIHRvIGRpc3BsYXkgdGhlIGN1cnJlbmN5IHNpZ24gb25seSBvbiBob3ZlciAoaWYgdGhlIGlucHV0IGlzIGVtcHR5KVxuICAgIHdFbXB0eTogJ2ZvY3VzJyxcblxuICAgIC8qIENvbnRyb2xzIGxlYWRpbmcgemVybyBiZWhhdmlvclxuICAgICAqIGxaZXJvOiBcImFsbG93XCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gWmVyb3Mgd2lsbCBiZSB0cnVuY2F0ZWQgd2hlbiBlbnRlcmluZyBhZGRpdGlvbmFsIGRpZ2l0cy4gT24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSBkZWxldGVkLlxuICAgICAqIGxaZXJvOiBcImRlbnlcIiwgLSBhbGxvd3Mgb25seSBvbmUgbGVhZGluZyB6ZXJvIG9uIHZhbHVlcyBsZXNzIHRoYW4gb25lXG4gICAgICogbFplcm86IFwia2VlcFwiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIG9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgcmV0YWluZWQuXG4gICAgICovXG4gICAgbFplcm86ICdhbGxvdycsXG5cbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSBmb3JtYXR0ZWQgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICogdHJ1ZSA9IGF1dG9tYXRpY2FsbHkgZm9ybWF0cyB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBpbml0aWFsaXphdGlvblxuICAgICAqIGZhbHNlID0gd2lsbCBub3QgZm9ybWF0IHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICovXG4gICAgYUZvcm06IHRydWUsXG5cbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdFxuICAgICAqIHRoZSBjb21wbGV0ZSBpbnB1dCB0ZXh0IG9yIG9ubHkgdGhlIGlucHV0IG51bWVyaWMgdmFsdWVcbiAgICAgKiBpZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduIG9ubHkgdGhlIG51bWVyaWMgdmFsdWUgd2lsbCBzZWxlY3RlZFxuICAgICAqL1xuICAgIHNOdW1iZXI6IGZhbHNlLFxuXG4gICAgLyogSGVscGVyIG9wdGlvbiBmb3IgQVNQLk5FVCBwb3N0YmFja1xuICAgICAqIHNob3VsZCBiZSB0aGUgdmFsdWUgb2YgdGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBleGFtcGxlczpcbiAgICAgKiBubyBkZWZhdWx0IHZhbHVlPVwiXCIge2FuRGVmYXVsdDogXCJcIn1cbiAgICAgKiB2YWx1ZT0xMjM0LjU2IHthbkRlZmF1bHQ6ICcxMjM0LjU2J31cbiAgICAgKi9cbiAgICBhbkRlZmF1bHQ6IG51bGwsXG5cbiAgICAvKiBSZW1vdmVzIGZvcm1hdHRpbmcgb24gc3VibWl0IGV2ZW50XG4gICAgICogdGhpcyBvdXRwdXQgZm9ybWF0OiBwb3NpdGl2ZSBubm5uLm5uLCBuZWdhdGl2ZSAtbm5ubi5ublxuICAgICAqIHJldmlldyB0aGUgJ3VuU2V0JyBtZXRob2QgZm9yIG90aGVyIGZvcm1hdHNcbiAgICAgKi9cbiAgICB1blNldE9uU3VibWl0OiBmYWxzZSxcblxuICAgIC8qIEFsbG93cyB0aGUgb3V0cHV0IHRvIGJlIGluIHRoZSBsb2NhbGUgZm9ybWF0IHZpYSB0aGUgXCJnZXRcIiwgXCJnZXRTdHJpbmdcIiAmIFwiZ2V0QXJyYXlcIiBtZXRob2RzXG4gICAgICogbnVsbCA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGRlZmF1bHRcbiAgICAgKiBcIixcIiAgPT4gbm5ubixubiBvciAtbm5ubixubiBjYW4gYWxzbyBiZSBcIi0sXCJcbiAgICAgKiBcIi4tXCIgPT4gbm5ubi5ubiBvciBubm5uLm5uLVxuICAgICAqIFwiLC1cIiA9PiBubm5uLG5uIG9yIG5ubm4sbm4tXG4gICAgICovXG4gICAgbG9jYWxlT3V0cHV0OiBudWxsLFxuXG4gICAgLyogRXJyb3IgaGFuZGxpbmcgZnVuY3Rpb25cbiAgICAgKiB0cnVlID0+IGFsbCBlcnJvcnMgYXJlIHRocm93biAtIGhlbHBmdWwgaW4gc2l0ZSBkZXZlbG9wbWVudFxuICAgICAqIGZhbHNlID0+IHRocm93cyBlcnJvcnMgd2hlbiBjYWxsaW5nIG1ldGhvZHMgcHJpb3IgdG8gdGhlIHN1cHBvcnRlZCBlbGVtZW50IGhhcyBiZWVuIGluaXRpYWxpemVkIGJlIGF1dG9OdW1lcmljXG4gICAgICovXG4gICAgZGVidWc6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBXcmFwcGVyIHZhcmlhYmxlIHRoYXQgaG9sZCBuYW1lZCBrZXlib2FyZCBrZXlzIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBrZXlDb2RlIGFzIHNlZW4gaW4gRE9NIGV2ZW50cy5cbiAqL1xuY29uc3Qga2V5Q29kZSA9IHtcbiAgICBCYWNrc3BhY2U6ICAgICAgOCxcbiAgICBUYWI6ICAgICAgICAgICAgOSxcbiAgICBFbnRlcjogICAgICAgICAgMTMsXG4gICAgU2hpZnQ6ICAgICAgICAgIDE2LFxuICAgIEN0cmw6ICAgICAgICAgICAxNyxcbiAgICBBbHQ6ICAgICAgICAgICAgMTgsXG4gICAgUGF1c2VCcmVhazogICAgIDE5LFxuICAgIENhcHNMb2NrOiAgICAgICAyMCxcbiAgICBFc2M6ICAgICAgICAgICAgMjcsXG4gICAgU3BhY2U6ICAgICAgICAgIDMyLFxuICAgIFBhZ2VVcDogICAgICAgICAzMyxcbiAgICBQYWdlRG93bjogICAgICAgMzQsXG4gICAgRW5kOiAgICAgICAgICAgIDM1LFxuICAgIEhvbWU6ICAgICAgICAgICAzNixcbiAgICBMZWZ0QXJyb3c6ICAgICAgMzcsXG4gICAgVXBBcnJvdzogICAgICAgIDM4LFxuICAgIFJpZ2h0QXJyb3c6ICAgICAzOSxcbiAgICBEb3duQXJyb3c6ICAgICAgNDAsXG4gICAgSW5zZXJ0OiAgICAgICAgIDQ1LFxuICAgIERlbGV0ZTogICAgICAgICA0NixcbiAgICBudW0wOiAgICAgICAgICAgNDgsXG4gICAgbnVtMTogICAgICAgICAgIDQ5LFxuICAgIG51bTI6ICAgICAgICAgICA1MCxcbiAgICBudW0zOiAgICAgICAgICAgNTEsXG4gICAgbnVtNDogICAgICAgICAgIDUyLFxuICAgIG51bTU6ICAgICAgICAgICA1MyxcbiAgICBudW02OiAgICAgICAgICAgNTQsXG4gICAgbnVtNzogICAgICAgICAgIDU1LFxuICAgIG51bTg6ICAgICAgICAgICA1NixcbiAgICBudW05OiAgICAgICAgICAgNTcsXG4gICAgYTogICAgICAgICAgICAgIDY1LFxuICAgIGI6ICAgICAgICAgICAgICA2NixcbiAgICBjOiAgICAgICAgICAgICAgNjcsXG4gICAgZDogICAgICAgICAgICAgIDY4LFxuICAgIGU6ICAgICAgICAgICAgICA2OSxcbiAgICBmOiAgICAgICAgICAgICAgNzAsXG4gICAgZzogICAgICAgICAgICAgIDcxLFxuICAgIGg6ICAgICAgICAgICAgICA3MixcbiAgICBpOiAgICAgICAgICAgICAgNzMsXG4gICAgajogICAgICAgICAgICAgIDc0LFxuICAgIGs6ICAgICAgICAgICAgICA3NSxcbiAgICBsOiAgICAgICAgICAgICAgNzYsXG4gICAgbTogICAgICAgICAgICAgIDc3LFxuICAgIG46ICAgICAgICAgICAgICA3OCxcbiAgICBvOiAgICAgICAgICAgICAgNzksXG4gICAgcDogICAgICAgICAgICAgIDgwLFxuICAgIHE6ICAgICAgICAgICAgICA4MSxcbiAgICByOiAgICAgICAgICAgICAgODIsXG4gICAgczogICAgICAgICAgICAgIDgzLFxuICAgIHQ6ICAgICAgICAgICAgICA4NCxcbiAgICB1OiAgICAgICAgICAgICAgODUsXG4gICAgdjogICAgICAgICAgICAgIDg2LFxuICAgIHc6ICAgICAgICAgICAgICA4NyxcbiAgICB4OiAgICAgICAgICAgICAgODgsXG4gICAgeTogICAgICAgICAgICAgIDg5LFxuICAgIHo6ICAgICAgICAgICAgICA5MCxcbiAgICBXaW5kb3dzOiAgICAgICAgOTEsXG4gICAgUmlnaHRDbGljazogICAgIDkzLFxuICAgIG51bXBhZDA6ICAgICAgICA5NixcbiAgICBudW1wYWQxOiAgICAgICAgOTcsXG4gICAgbnVtcGFkMjogICAgICAgIDk4LFxuICAgIG51bXBhZDM6ICAgICAgICA5OSxcbiAgICBudW1wYWQ0OiAgICAgICAgMTAwLFxuICAgIG51bXBhZDU6ICAgICAgICAxMDEsXG4gICAgbnVtcGFkNjogICAgICAgIDEwMixcbiAgICBudW1wYWQ3OiAgICAgICAgMTAzLFxuICAgIG51bXBhZDg6ICAgICAgICAxMDQsXG4gICAgbnVtcGFkOTogICAgICAgIDEwNSxcbiAgICBNdWx0aXBseU51bXBhZDogMTA2LFxuICAgIFBsdXNOdW1wYWQ6ICAgICAxMDcsXG4gICAgTWludXNOdW1wYWQ6ICAgIDEwOSxcbiAgICBEb3ROdW1wYWQ6ICAgICAgMTEwLFxuICAgIFNsYXNoTnVtcGFkOiAgICAxMTEsXG4gICAgRjE6ICAgICAgICAgICAgIDExMixcbiAgICBGMjogICAgICAgICAgICAgMTEzLFxuICAgIEYzOiAgICAgICAgICAgICAxMTQsXG4gICAgRjQ6ICAgICAgICAgICAgIDExNSxcbiAgICBGNTogICAgICAgICAgICAgMTE2LFxuICAgIEY2OiAgICAgICAgICAgICAxMTcsXG4gICAgRjc6ICAgICAgICAgICAgIDExOCxcbiAgICBGODogICAgICAgICAgICAgMTE5LFxuICAgIEY5OiAgICAgICAgICAgICAxMjAsXG4gICAgRjEwOiAgICAgICAgICAgIDEyMSxcbiAgICBGMTE6ICAgICAgICAgICAgMTIyLFxuICAgIEYxMjogICAgICAgICAgICAxMjMsXG4gICAgTnVtTG9jazogICAgICAgIDE0NCxcbiAgICBTY3JvbGxMb2NrOiAgICAgMTQ1LFxuICAgIE15Q29tcHV0ZXI6ICAgICAxODIsXG4gICAgTXlDYWxjdWxhdG9yOiAgIDE4MyxcbiAgICBTZW1pY29sb246ICAgICAgMTg2LFxuICAgIEVxdWFsOiAgICAgICAgICAxODcsXG4gICAgQ29tbWE6ICAgICAgICAgIDE4OCxcbiAgICBIeXBoZW46ICAgICAgICAgMTg5LFxuICAgIERvdDogICAgICAgICAgICAxOTAsXG4gICAgU2xhc2g6ICAgICAgICAgIDE5MSxcbiAgICBCYWNrcXVvdGU6ICAgICAgMTkyLFxuICAgIExlZnRCcmFja2V0OiAgICAyMTksXG4gICAgQmFja3NsYXNoOiAgICAgIDIyMCxcbiAgICBSaWdodEJyYWNrZXQ6ICAgMjIxLFxuICAgIFF1b3RlOiAgICAgICAgICAyMjIsXG4gICAgQ29tbWFuZDogICAgICAgIDIyNCxcbn07XG5cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAvL1RPRE8gVGhpcyBzdXJlbHkgY2FuIGJlIGltcHJvdmVkIGJ5IGxldHRpbmcgd2VicGFjayB0YWtlIGNhcmUgb2YgZ2VuZXJhdGluZyB0aGlzIFVNRCBwYXJ0XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBOb2RlL0NvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcbn0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeSh3aW5kb3cualF1ZXJ5KTtcbn1cbn0oJCA9PiB7XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCgwKSB8fCAnJyA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBpcyBhIFN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBib29sZWFuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgJ3RydWUnIG9yICdmYWxzZSdcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbnkgY2FzZXMgZm9yIHRob3NlIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUcnVlT3JGYWxzZVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsb3dlcmNhc2VWYWx1ZSA9IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyY2FzZVZhbHVlID09PSAndHJ1ZScgfHwgbG93ZXJjYXNlVmFsdWUgPT09ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVmZXJlbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QocmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2UgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGVtcHR5XG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0IGFuZCBodHRwOi8vanNwZXJmLmNvbS9lbXB0eS1vYmplY3QtdGVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9ialxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHRleHQgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIgaXMgdmFsaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRQYXN0ZVRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dCAhPT0gJycgJiYgIWlzTmFOKHRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcGFzdGVkIHRleHQgdGhhdCB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dFxuICAgICAqIEBwYXJhbSBob2xkZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHZvaWR8WE1MfCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJlcGFyZVBhc3RlZFRleHQodGV4dCwgaG9sZGVyKSB7XG4gICAgICAgIHJldHVybiBhdXRvU3RyaXAodGV4dCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUpLnJlcGxhY2UoaG9sZGVyLnNldHRpbmdzQ2xvbmUuYURlYywgJy4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc3RyaW5nIGBzdHJgIGNvbnRhaW5zIHRoZSBzdHJpbmcgYG5lZWRsZWBcbiAgICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvZXJjZSB0aGUgcGFyYW1ldGVycyB0eXBlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZWVkbGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhzdHIsIG5lZWRsZSkge1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHN0cikgfHwgIWlzU3RyaW5nKG5lZWRsZSkgfHwgc3RyID09PSAnJyB8fCBuZWVkbGUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGBuZWVkbGVgIGlzIGluIHRoZSBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IG5lZWRsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5BcnJheShuZWVkbGUsIGFycmF5KSB7XG4gICAgICAgIGlmICghaXNBcnJheShhcnJheSkgfHwgYXJyYXkgPT09IFtdIHx8IGlzVW5kZWZpbmVkKG5lZWRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gQXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gYXJyXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHsgLy8gTWFrZSBzdXJlIGFuIGFycmF5IGhhcyBhIGNsYXNzIGF0dHJpYnV0ZSBvZiBbb2JqZWN0IEFycmF5XVxuICAgICAgICAgICAgLy8gVGVzdCBwYXNzZWQsIG5vdyBjaGVjayBpZiBpcyBhbiBBcnJheVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSB8fCAodHlwZW9mIGFyciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b1N0cmluZyBtZXNzYWdlIGNoYW5nZWQgZm9yIE9iamVjdCBBcnJheScpOyAvLyBWZXJpZnkgdGhhdCB0aGUgc3RyaW5nIHJldHVybmVkIGJ5IGB0b1N0cmluZ2AgZG9lcyBub3QgY2hhbmdlIGluIHRoZSBmdXR1cmUgKGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MzY1MjE1KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNEZWNpbWFscyhzdHIpIHtcbiAgICAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmxvYXQgbnVtYmVyLCBhbmQgdGhhdCBudW1iZXIgaGFzIGEgZGVjaW1hbCBwYXJ0LlxuICAgICAqIFJldHVybiBgbnVsbGAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm5zIHtudWxsfGludH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWNpbWFsUGxhY2VzKHN0cikge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGFydC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIGdldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudFNlbGVjdGlvbih0aGF0KSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge307XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xuICAgICAgICAgICAgdGhhdC5mb2N1cygpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBzZWxlY3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzZWxlY3QubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtdGhhdC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gc2VsZWN0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHRoYXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSB0aGF0LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLnN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3Igc2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoYXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBoYW5kbGUgZXJyb3JzIG1lc3NhZ2VzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvcihtZXNzYWdlLCBkZWJ1ZyA9IHRydWUpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBoYW5kbGUgd2FybmluZyBtZXNzYWdlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSwgc3VwcHJlc3NXYXJuaW5ncyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzdXBwcmVzc1dhcm5pbmdzKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tY29uc29sZTogMCAqL1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiAke21lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdXRvTnVtZXJpYy1zcGVjaWZpYyBmdW5jdGlvbnNcblxuICAgIC8qKlxuICAgICAqIHJ1biBjYWxsYmFja3MgaW4gcGFyYW1ldGVycyBpZiBhbnlcbiAgICAgKiBhbnkgcGFyYW1ldGVyIGNvdWxkIGJlIGEgY2FsbGJhY2s6XG4gICAgICogLSBhIGZ1bmN0aW9uLCB3aGljaCBpbnZva2VkIHdpdGggalF1ZXJ5IGVsZW1lbnQsIHBhcmFtZXRlcnMgYW5kIHRoaXMgcGFyYW1ldGVyIG5hbWUgYW5kIHJldHVybnMgcGFyYW1ldGVyIHZhbHVlXG4gICAgICogLSBhIG5hbWUgb2YgZnVuY3Rpb24sIGF0dGFjaGVkIHRvICQoc2VsZWN0b3IpLmF1dG9OdW1lcmljLmZ1bmN0aW9uTmFtZSgpe30gLSB3aGljaCB3YXMgY2FsbGVkIHByZXZpb3VzbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBydW5DYWxsYmFja3MoJHRoaXMsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vIGxvb3BzIHRocm91Z2ggdGhlIHNldHRpbmdzIG9iamVjdCAob3B0aW9uIGFycmF5KSB0byBmaW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoaywgdmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gdmFsKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbHMgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGZyb20gdGhlIGh0bWw1IGRhdGEgZXhhbXBsZTogZGF0YS1hLXNpZ249XCJmdW5jdGlvbk5hbWVcIlxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gJHRoaXMuYXV0b051bWVyaWNbdmFsXSgkdGhpcywgc2V0dGluZ3MsIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRlY2ltYWwgbGVuZ3RoIGZyb20gdGhlIHZNaW4gdk1heCBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY0xlbmd0aCh2TWluLCB2TWF4KSB7XG4gICAgICAgIGxldCB2TWF4TGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IHZNaW5MZW5ndGggPSAwO1xuICAgICAgICBpZiAodk1heFsxXSkge1xuICAgICAgICAgICAgdk1heExlbmd0aCA9IHZNYXhbMV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2TWluWzFdKSB7XG4gICAgICAgICAgICB2TWluTGVuZ3RoID0gdk1pblsxXS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodk1heExlbmd0aCwgdk1pbkxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyaW5nIHVzZXIgZGVmaW5lZCBvcHRpb25zIGZvciBmdXJ0aGVyIHVzYWdlXG4gICAgICogbWVyZ2UgdGhlbSB3aXRoIGRlZmF1bHRzIGFwcHJvcHJpYXRlbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvQ29kZSgkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgcnVuQ2FsbGJhY2tzKCR0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IHZNYXggPSBzZXR0aW5ncy52TWF4LnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3Qgdk1pbiA9ICghc2V0dGluZ3Mudk1pbiAmJiBzZXR0aW5ncy52TWluICE9PSAwKSA/IFtdIDogc2V0dGluZ3Mudk1pbi50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIHNldHRpbmdzLmFOZWcgPSBzZXR0aW5ncy52TWluIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB2TWF4WzBdID0gdk1heFswXS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB2TWluWzBdID0gdk1pblswXS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICBzZXR0aW5ncy5tSW50UG9zID0gTWF0aC5tYXgodk1heFswXS5sZW5ndGgsIDEpO1xuICAgICAgICBzZXR0aW5ncy5tSW50TmVnID0gTWF0aC5tYXgodk1pblswXS5sZW5ndGgsIDEpO1xuICAgICAgICBpZiAoc2V0dGluZ3MubURlYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IGRlY0xlbmd0aCh2TWluLCB2TWF4KTtcbiAgICAgICAgICAgIHNldHRpbmdzLm9EZWMgPSBzZXR0aW5ncy5tRGVjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IE51bWJlcihzZXR0aW5ncy5tRGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNjYWxlRGVjaW1hbCkgPyBzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiBzZXR0aW5ncy5tRGVjO1xuXG4gICAgICAgIC8vIHNldCBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciBrZXlcbiAgICAgICAgaWYgKHNldHRpbmdzLmFsdERlYyA9PT0gbnVsbCAmJiBzZXR0aW5ncy5tRGVjID4gMCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFEZWMgPT09ICcuJyAmJiBzZXR0aW5ncy5hU2VwICE9PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHREZWMgPSAnLCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmFEZWMgPT09ICcsJyAmJiBzZXR0aW5ncy5hU2VwICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHREZWMgPSAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWNoZSByZWdleHBzIGZvciBhdXRvU3RyaXBcbiAgICAgICAgY29uc3QgYU5lZ1JlZyA9IHNldHRpbmdzLmFOZWcgP2AoWy1cXFxcJHtzZXR0aW5ncy5hTmVnfV0/KWAgOicoLT8pJztcbiAgICAgICAgc2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcCA9IGFOZWdSZWc7XG4gICAgICAgIHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ31bXi0keyhzZXR0aW5ncy5hTmVnP2BcXFxcJHtzZXR0aW5ncy5hTmVnfWA6JycpfVxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGRdLio/KFxcXFxkfFxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQpYCk7XG4gICAgICAgIHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgKFxcXFxkXFxcXCR7c2V0dGluZ3MuYURlY30/KVteXFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZF1cXFxcRCokYCk7XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5hRGVjfWA7XG4gICAgICAgIHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XG4gICAgICAgIHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ30oPzpcXFxcJHtzZXR0aW5ncy5hRGVjfT8oXFxcXGQrXFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZCspfChcXFxcZCooPzpcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKik/KSlgKTtcblxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc3RyaXAgYWxsIHVud2FudGVkIGNoYXJhY3RlcnMgYW5kIGxlYXZlIG9ubHkgYSBudW1iZXIgYWxlcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvU3RyaXAocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmFTaWduICE9PSAnJykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYVNpZ24sICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYVN1ZmZpeCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHN1ZmZpeFxuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5zKHMsIHNldHRpbmdzLmFTdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hU3VmZml4LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCByZXBsYWNlIGFueXRoaW5nIGJlZm9yZSBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAsICckMSQyJyk7XG5cbiAgICAgICAgaWYgKChzZXR0aW5ncy5wTmVnID09PSAncycgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyAhPT0gJ3AnKSkgJiYgY29udGFpbnMocywgJy0nKSAmJiBzICE9PSAnJykge1xuICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGVuIHJlcGxhY2UgYW55dGhpbmcgYWZ0ZXIgZGlnaXRzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAsICckMScpO1xuXG4gICAgICAgIC8vIHRoZW4gcmVtb3ZlIGFueSB1bmludGVyZXN0ZWQgY2hhcmFjdGVyc1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAsICcnKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmFsdERlYykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hbHREZWMsIHNldHRpbmdzLmFEZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IG9ubHkgbnVtYmVyIHN0cmluZ1xuICAgICAgICBjb25zdCBtID0gcy5tYXRjaChzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXApO1xuICAgICAgICBzID0gbSA/IFttWzFdLCBtWzJdLCBtWzNdXS5qb2luKCcnKSA6ICcnO1xuICAgICAgICBpZiAoc2V0dGluZ3MubFplcm8gPT09ICdhbGxvdycgfHwgc2V0dGluZ3MubFplcm8gPT09ICdrZWVwJykge1xuICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoc2V0dGluZ3MuYURlYyk7XG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IGludGVnZXJQYXJ0O1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKG1vZGlmaWVkSW50ZWdlclBhcnQsIHNldHRpbmdzLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgblNpZ24gPSBzZXR0aW5ncy5hTmVnO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnJlcGxhY2Uoc2V0dGluZ3MuYU5lZywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gcG9zaXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBtb2RpZmllZEludGVnZXJQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1JbnRQb3MgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgaWYgKG5TaWduICE9PSAnJyAmJiBtb2RpZmllZEludGVnZXJQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1JbnROZWcgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IGAke25TaWdufSR7bW9kaWZpZWRJbnRlZ2VyUGFydH0ke2lzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KT8nJzpzZXR0aW5ncy5hRGVjICsgZGVjaW1hbFBhcnR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNldHRpbmdzLm9uT2ZmICYmIHNldHRpbmdzLmxaZXJvID09PSAnZGVueScpIHx8IChzZXR0aW5ncy5sWmVybyA9PT0gJ2FsbG93JyAmJiBzZXR0aW5ncy5vbk9mZiA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAvLyBVc2luZyB0aGlzIHJlZ2V4IHZlcnNpb24gYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGR8JClgIGVudGlyZWx5IGNsZWFyIHRoZSBpbnB1dCBvbiBibHVyXG4gICAgICAgICAgICBsZXQgc3RyaXBSZWcgPSBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZClgO1xuICAgICAgICAgICAgc3RyaXBSZWcgPSBuZXcgUmVnRXhwKHN0cmlwUmVnKTtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc3RyaXBSZWcsICckMSQyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwbGFjZXMgb3IgcmVtb3ZlcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGl2ZUJyYWNrZXQocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKChzZXR0aW5ncy5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3AnKSkge1xuICAgICAgICAgICAgY29uc3QgW2ZpcnN0QnJhY2tldCwgbGFzdEJyYWNrZXRdID0gc2V0dGluZ3MubkJyYWNrZXQuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub25PZmYpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICcnKTtcbiAgICAgICAgICAgICAgICBzID0gZmlyc3RCcmFja2V0ICsgcyArIGxhc3RCcmFja2V0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5vbk9mZiAmJiBzLmNoYXJBdCgwKSA9PT0gZmlyc3RCcmFja2V0KSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShmaXJzdEJyYWNrZXQsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UobGFzdEJyYWNrZXQsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgbG9jYWxlIGZvcm1hdCB0byBKYXZhc2NyaXB0IG51bWVyaWMgc3RyaW5nXG4gICAgICogYWxsb3dzIGxvY2FsZSBkZWNpbWFsIHNlcGFyYXRvciB0byBiZSBhIHBlcmlvZCBvciBjb21tYSAtIG5vIHRob3VzYW5kIHNlcGFyYXRvciBhbGxvd2VkIG9mIGN1cnJlbmN5IHNpZ25zIGFsbG93ZWRcbiAgICAgKiAnMTIzNC41NicgICAgT0tcbiAgICAgKiAnLTEyMzQuNTYnICAgT0tcbiAgICAgKiAnMTIzNC41Ni0nICAgT0tcbiAgICAgKiAnMTIzNCw1NicgICAgT0tcbiAgICAgKiAnLTEyMzQsNTYnICAgT0tcbiAgICAgKiAnMTIzNCw1Ni0nICAgT0tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tTG9jYWxlKHMpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnLCcsICcuJyk7XG4gICAgICAgIGlmIChjb250YWlucyhzLCAnLScpICYmIHMubGFzdEluZGV4T2YoJy0nKSA9PT0gcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgcyA9ICctJyArIHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgSVNPIG51bWVyaWMgc3RyaW5nIHRvIHRoZSBsb2NhbGUgZGVjaW1hbCBhbmQgbWludXMgc2lnbiBwbGFjZW1lbnQuXG4gICAgICogU2VlIHRoZSBcImxvY2FsZU91dHB1dFwiIG9wdGlvbiBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb2NhbGUodmFsdWUsIGxvY2FsZSkge1xuICAgICAgICBpZiAoaXNOdWxsKGxvY2FsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHN3aXRjaCAobG9jYWxlKSB7XG4gICAgICAgICAgICBjYXNlICcuLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29udGFpbnModmFsdWUsICctJykgPyB2YWx1ZS5yZXBsYWNlKCctJywgJycpICsgJy0nIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIGNhc2UgJy0sJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJywtJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb250YWlucyhyZXN1bHQsICctJykgPyByZXN1bHQucmVwbGFjZSgnLScsICcnKSArICctJyA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGNhc2VcbiAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgY2FzZSAnLS4nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGdpdmVuIGxvY2FsZU91dHB1dCBbJHtsb2NhbGV9XSBvcHRpb24gaXMgbm90IHJlY29nbml6ZWQuYCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXBhcmUgbnVtYmVyIHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgdG8gcmVhbCBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXhOdW1iZXIocywgYURlYywgYU5lZykge1xuICAgICAgICBpZiAoYURlYyAmJiBhRGVjICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYURlYywgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYU5lZyAmJiBhTmVnICE9PSAnLScpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYU5lZywgJy0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXMubWF0Y2goL1xcZC8pKSB7XG4gICAgICAgICAgICBzICs9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXBhcmUgcmVhbCBudW1iZXIgdG8gYmUgY29udmVydGVkIHRvIG91ciBmb3JtYXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVzZW50TnVtYmVyKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hTmVnICYmIHNldHRpbmdzLmFOZWcgIT09ICctJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5hRGVjICYmIHNldHRpbmdzLmFEZWMgIT09ICcuJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLicsIHNldHRpbmdzLmFEZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiB0byBjaGVjayBmb3IgZW1wdHkgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0VtcHR5KGl2LCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgaWYgKGl2ID09PSAnJyB8fCBpdiA9PT0gc2V0dGluZ3MuYU5lZykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLndFbXB0eSA9PT0gJ2Fsd2F5cycgfHwgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNldHRpbmdzLnBOZWcgPT09ICdsJykgPyBpdiArIHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYVN1ZmZpeCA6IHNldHRpbmdzLmFTaWduICsgaXYgKyBzZXR0aW5ncy5hU3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgb3VyIG51bWJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Hcm91cChpdiwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XG4gICAgICAgICAgICBpdiA9IGF1dG9TdHJpcChpdiwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhpdiwgJy0nKSkge1xuICAgICAgICAgICAgaXYgPSAnLScgKyBpdjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbXB0eSA9IGNoZWNrRW1wdHkoaXYsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaXNOZWcgPSBjb250YWlucyhpdiwgJy0nKTtcbiAgICAgICAgaWYgKGlzTmVnKSB7XG4gICAgICAgICAgICBpdiA9IGl2LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZ2l0YWxHcm91cCA9ICcnO1xuICAgICAgICBzZXR0aW5ncy5kR3JvdXAgPSBzZXR0aW5ncy5kR3JvdXAudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRHcm91cCA9PT0gJzInKSB7XG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZCkoXFxkezJ9PykrKSQvO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmRHcm91cCA9PT0gJzJzJykge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKCg/OlxcZHsyfSl7MCwyfVxcZHszfSg/Oig/OlxcZHsyfSl7Mn1cXGR7M30pKj8pJC87XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZEdyb3VwID09PSAnNCcpIHtcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezR9PykrKSQvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7M30/KSspJC87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGxpdHMgdGhlIHN0cmluZyBhdCB0aGUgZGVjaW1hbCBzdHJpbmdcbiAgICAgICAgbGV0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaXYuc3BsaXQoc2V0dGluZ3MuYURlYyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMgJiYgaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGl2LnNwbGl0KHNldHRpbmdzLmFsdERlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFTZXAgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyByZS1pbnNlcnRzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdmlhIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRhbEdyb3VwLnRlc3QoaW50ZWdlclBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydC5yZXBsYWNlKGRpZ2l0YWxHcm91cCwgYCQxJHtzZXR0aW5ncy5hU2VwfSQyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLm1EZWMgIT09IDAgJiYgIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1EZWMpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5tRGVjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gam9pbnMgdGhlIHdob2xlIG51bWJlciB3aXRoIHRoZSBkZWNpbWFsIHZhbHVlXG4gICAgICAgICAgICBpdiA9IGludGVnZXJQYXJ0ICsgc2V0dGluZ3MuYURlYyArIGRlY2ltYWxQYXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2hvbGUgbnVtYmVycyBvbmx5XG4gICAgICAgICAgICBpdiA9IGludGVnZXJQYXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5wU2lnbiA9PT0gJ3AnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hTmVnICsgc2V0dGluZ3MuYVNpZ24gKyBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncicpIHtcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYU5lZyArIGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYVNpZ24gKyBpdiArIHNldHRpbmdzLmFOZWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmVnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hU2lnbiArIGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBpdiArIHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYU5lZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICBpdiA9IGl2ICsgc2V0dGluZ3MuYU5lZyArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdwJykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYU5lZyArIGl2ICsgc2V0dGluZ3MuYVNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmVnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBpdiArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgcGxhY2VzIGJyYWNrZXRzXG4gICAgICAgIGlmIChzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiAoc2V0dGluZ3MucmF3VmFsdWUgPCAwIHx8IGl2LmNoYXJBdCgwKSA9PT0gJy0nKSkge1xuICAgICAgICAgICAgaXYgPSBuZWdhdGl2ZUJyYWNrZXQoaXYsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIGl2ICsgc2V0dGluZ3MuYVN1ZmZpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZSBub3QgbmVlZGVkIHplcm9zXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHJEZWMpIHtcbiAgICAgICAgbGV0IHJlZ2V4O1xuICAgICAgICBzd2l0Y2ggKHJEZWMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBwYWRkaW5nIC0gcmVtb3ZlcyB0cmFpbGluZyB6ZXJvcyB0byB0aGUgZmlyc3Qgc2lnbmlmaWNhbnQgZGlnaXRcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvLyBBbGxvd3MgcGFkZGluZyB3aGVuIG1EZWMgZXF1YWxzIG9uZSAtIGxlYXZlcyBvbmUgemVybyB0cmFpbGluZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgYWNjZXNzIHplcm9zIHRvIHRoZSBtRGVjIGxlbmd0aCB3aGVuIGFQYWQgaXMgc2V0IHRydWVcbiAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoYChcXFxcLlxcXFxkeyR7ckRlY319KD86XFxcXGQqWzEtOV0pPykwKmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlY2ltYWwgcGxhY2VzLCB3ZSBkb24ndCBuZWVkIGEgZGVjaW1hbCBwb2ludCBhdCB0aGUgZW5kXG4gICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKHJlZ2V4LCAnJDEnKTtcbiAgICAgICAgaWYgKHJEZWMgPT09IDApIHtcbiAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl2Um91bmRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByb3VuZCBudW1iZXIgYWZ0ZXIgc2V0dGluZyBieSBwYXN0aW5nIG9yICQoKS5hdXRvTnVtZXJpY1NldCgpXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiBmb3Igcm91bmQgdGhlIG51bWJlclxuICAgICAqIHBsZWFzZSBub3RlIHRoaXMgaGFuZGxlZCBhcyB0ZXh0IC0gSmF2YVNjcmlwdCBtYXRoIGZ1bmN0aW9uIGNhbiByZXR1cm4gaW5hY2N1cmF0ZSB2YWx1ZXNcbiAgICAgKiBhbHNvIHRoaXMgb2ZmZXJzIG11bHRpcGxlIHJvdW5kaW5nIG1ldGhvZHMgdGhhdCBhcmUgbm90IGVhc2lseSBhY2NvbXBsaXNoZWQgaW4gSmF2YVNjcmlwdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Sb3VuZChpdiwgc2V0dGluZ3MpIHsgLy8gdmFsdWUgdG8gc3RyaW5nXG4gICAgICAgIGl2ID0gKGl2ID09PSAnJykgPyAnMCcgOiBpdi50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3MubVJvdW5kID09PSAnTjA1JyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdDSEYnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1UwNScgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnRDA1Jykge1xuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5tUm91bmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdOMDUnOlxuICAgICAgICAgICAgICAgICAgICBpdiA9IChNYXRoLnJvdW5kKGl2ICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1UwNSc6XG4gICAgICAgICAgICAgICAgICAgIGl2ID0gKE1hdGguY2VpbChpdiAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgaXYgPSAoTWF0aC5mbG9vcihpdiAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFjb250YWlucyhpdiwgJy4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl2ICsgJy4wMCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl2Lmxlbmd0aCAtIGl2LmluZGV4T2YoJy4nKSA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdiArICcwJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl2Um91bmRlZCA9ICcnO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICBsZXQgckRlYztcblxuICAgICAgICAvLyBzZXRzIHRoZSB0cnVuY2F0ZSB6ZXJvIG1ldGhvZFxuICAgICAgICBpZiAoc2V0dGluZ3MuYVBhZCkge1xuICAgICAgICAgICAgckRlYyA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByRGVjID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgaXYgKGlucHV0IFZhbHVlKSBpcyBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGlmIChpdi5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgblNpZ24gPSAnLSc7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gdGhhdCB3aWxsIGJlIGFkZGVkIGJhY2sgbGF0ZXIgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgIGl2ID0gaXYucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCBhIHplcm8gaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBub3QgYSBkaWdpdCAodGhlbiBpdCBpcyBsaWtlbHkgdG8gYmUgYSBkb3QpXG4gICAgICAgIGlmICghaXYubWF0Y2goL15cXGQvKSkge1xuICAgICAgICAgICAgaXYgPSAnMCcgKyBpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIGVxdWFsIHRvIHplcm8uIElmIGl0IGlzLCByZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgTnVtYmVyKGl2KSA9PT0gMCkge1xuICAgICAgICAgICAgblNpZ24gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaW1zIGxlYWRpbmcgemVybydzIGFzIG5lZWRlZFxuICAgICAgICBpZiAoKE51bWJlcihpdikgPiAwICYmIHNldHRpbmdzLmxaZXJvICE9PSAna2VlcCcpIHx8IChpdi5sZW5ndGggPiAwICYmIHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnKSkge1xuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZFBvcyA9IGl2Lmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgICAgLy8gVmlydHVhbCBkZWNpbWFsIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHZkUG9zID0gKGRQb3MgPT09IC0xKSA/IGl2Lmxlbmd0aCAtIDEgOiBkUG9zO1xuXG4gICAgICAgIC8vIENoZWNrcyBkZWNpbWFsIHBsYWNlcyB0byBkZXRlcm1pbmUgaWYgcm91bmRpbmcgaXMgcmVxdWlyZWQgOlxuICAgICAgICAvLyBDaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxuICAgICAgICBsZXQgY0RlYyA9IChpdi5sZW5ndGggLSAxKSAtIHZkUG9zO1xuXG4gICAgICAgIGlmIChjRGVjIDw9IHNldHRpbmdzLm1EZWMpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gcGFkIHdpdGggemVyb3NcbiAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2O1xuICAgICAgICAgICAgaWYgKGNEZWMgPCByRGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRQb3MgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSBzZXR0aW5ncy5hRGVjO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB6ZXJvcyA9ICcwMDAwMDAnO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjRGVjIDwgckRlYykge1xuICAgICAgICAgICAgICAgICAgICB6ZXJvcyA9IHplcm9zLnN1YnN0cmluZygwLCByRGVjIC0gY0RlYyk7XG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSB6ZXJvcztcbiAgICAgICAgICAgICAgICAgICAgY0RlYyArPSB6ZXJvcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID4gckRlYykge1xuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZSb3VuZGVkLCByRGVjKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA9PT0gMCAmJiByRGVjID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSb3VuZGVkIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGFmdGVyIHJvdW5kaW5nXG4gICAgICAgIGNvbnN0IHJMZW5ndGggPSBkUG9zICsgc2V0dGluZ3MubURlYzsgLy9UT0RPIE1vZGlmeSBgZFBvc2AgaGVyZSBpZiBpdCdzIG5vdCBpbnRlbmRlZCB0aGF0IGl0IGNhbiBiZSBlcXVhbCB0byAnLTEnXG4gICAgICAgIGNvbnN0IHRSb3VuZCA9IE51bWJlcihpdi5jaGFyQXQockxlbmd0aCArIDEpKTtcbiAgICAgICAgY29uc3Qgb2RkID0gKGl2LmNoYXJBdChyTGVuZ3RoKSA9PT0gJy4nKSA/IChpdi5jaGFyQXQockxlbmd0aCAtIDEpICUgMikgOiAoaXYuY2hhckF0KHJMZW5ndGgpICUgMik7XG4gICAgICAgIGxldCBpdkFycmF5ID0gaXYuc3Vic3RyaW5nKDAsIHJMZW5ndGggKyAxKS5zcGxpdCgnJyk7XG5cbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdzJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdhJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ2EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQicpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA9PT0gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdCJyAmJiBvZGQgPT09IDEpICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQycgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgdG8gY2VpbGluZyB0b3dhcmQgcG9zaXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0YnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIHRvIGZsb29yIHRvd2FyZCBuZWdhdGl2ZSBpbmZpbml0ZVxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnVScpKSB7ICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgYXdheSBmcm9tIHplcm9cbiAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRoZSBsYXN0IGRpZ2l0IGlmIHJlcXVpcmVkLCBhbmQgY29udGludWUgdW50aWwgbm8gbW9yZSA5J3MgYXJlIGZvdW5kXG4gICAgICAgICAgICBmb3IgKGkgPSAoaXZBcnJheS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAraXZBcnJheVtpXSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIHN0cmluZywgY29udmVydGluZyBhbnkgMTAncyB0byAwJ3NcbiAgICAgICAgaXZBcnJheSA9IGl2QXJyYXkuc2xpY2UoMCwgckxlbmd0aCArIDEpO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcm91bmRlZCB2YWx1ZVxuICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2QXJyYXkuam9pbignJyksIHJEZWMpO1xuXG4gICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3RlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVEZWNpbWFsKHMsIHNldHRpbmdzLCBwYXN0ZSkge1xuICAgICAgICBjb25zdCBhRGVjID0gc2V0dGluZ3MuYURlYztcbiAgICAgICAgY29uc3QgbURlYyA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIHMgPSAocGFzdGUgPT09ICdwYXN0ZScpID8gYXV0b1JvdW5kKHMsIHNldHRpbmdzKSA6IHM7XG5cbiAgICAgICAgaWYgKGFEZWMgJiYgbURlYykge1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KGFEZWMpO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQgJiYgZGVjaW1hbFBhcnQubGVuZ3RoID4gbURlYykge1xuICAgICAgICAgICAgICAgIGlmIChtRGVjID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIG1EZWMpO1xuICAgICAgICAgICAgICAgICAgICBzID0gYCR7aW50ZWdlclBhcnR9JHthRGVjfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSB2TWluLCB2TWF4ICYgdGhlIGlucHV0IHZhbHVlIHRvIHByZXBhcmUgZm9yIHRlc3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiAvIG1heCByYW5nZVxuICAgICAqIFJldHVybiBhbiBvYmplY3QgZXhhbXBsZTogdk1pbjogXCI5OTk5OTk5OTk5OTk5OTkuOTlcIiByZXR1cm5zIHRoZSBmb2xsb3dpbmcgXCJ7czogLTEsIGU6IDEyLCBjOiBBcnJheVsxNV19XCJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL1xuICAgICAqIE1hbnkgdGhhbmtzIHRvIE1pa2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbkw7XG4gICAgICAgIGxldCBqO1xuXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICAgICAgbiA9ICctMCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xuICAgICAgICAgICAgeC5zID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LnMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZSA+IC0xKSB7XG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAoZSA8IDApIHtcbiAgICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcbiAgICAgICAgbkwgPSBuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XG4gICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5jID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xuICAgICAgICAgICAgICAgIG5MIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuTCAtPSAxO1xuXG4gICAgICAgICAgICAvLyBEZWNpbWFsIGxvY2F0aW9uXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XG4gICAgICAgICAgICB4LmMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgeC5jW2VdID0gK24uY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGlucHV0IHZhbHVlIGZhbGxzIHdpdGggdGhlIE1pbiAvIE1heCBzZXR0aW5nc1xuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvblxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gICAgICogTWFueSB0aGFua3MgdG8gTWlrZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlc3RNaW5NYXgoeSwgeCkge1xuICAgICAgICBjb25zdCB4YyA9IHguYztcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XG4gICAgICAgIGxldCBpID0geC5zO1xuICAgICAgICBsZXQgaiA9IHkucztcbiAgICAgICAgbGV0IGsgPSB4LmU7XG4gICAgICAgIGxldCBsID0geS5lO1xuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHNcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcbiAgICAgICAgbCA9IHljLmxlbmd0aDtcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcblxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0XG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4Y1tpXSA+IHljW2ldIF4geE5lZyk/MTotMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoayA9PT0gbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNraW5nIHRoYXQgbnVtYmVyIHNhdGlzZnkgZm9ybWF0IGNvbmRpdGlvbnNcbiAgICAgKiBhbmQgbGF5cyBiZXR3ZWVuIHNldHRpbmdzLnZNaW4gYW5kIHNldHRpbmdzLnZNYXhcbiAgICAgKiBhbmQgdGhlIHN0cmluZyBsZW5ndGggZG9lcyBub3QgZXhjZWVkIHRoZSBkaWdpdHMgaW4gc2V0dGluZ3Mudk1pbiBhbmQgc2V0dGluZ3Mudk1heFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9DaGVjayhzLCBzZXR0aW5ncykge1xuICAgICAgICBzID0gcy50b1N0cmluZygpO1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWluKTtcbiAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWF4KTtcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm9MaW1pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VpbGluZyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b0dldChvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgb2JqID0gb2JqLnJlcGxhY2UoL1xcWy9nLCAnXFxcXFsnKS5yZXBsYWNlKC9dL2csICdcXFxcXScpO1xuICAgICAgICAgICAgb2JqID0gJyMnICsgb2JqLnJlcGxhY2UoLyg6fFxcLikvZywgJ1xcXFwkMScpO1xuICAgICAgICAgICAgLy8gcG9zc2libGUgbW9kaWZpY2F0aW9uIHRvIHJlcGxhY2UgdGhlIGFib3ZlIDIgbGluZXNcbiAgICAgICAgICAgIC8vIG9iaiA9ICcjJyArIG9iai5yZXBsYWNlKC8oWzsmLFxcLlxcK1xcKlxcfic6XCJcXCFcXF4jJCVAXFxbXFxdXFwoXFwpPT5cXHxdKS9nLCAnXFxcXCQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRvIGF0dGFjaCBkYXRhIHRvIHRoZSBlbGVtZW50XG4gICAgICogYW5kIGltaXRhdGUgdGhlIGhvbGRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcigkdGhhdCwgc2V0dGluZ3MsIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBkYXRhID0gJHRoYXQuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICAkdGhhdC5kYXRhKCdhdXRvTnVtZXJpYycsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhvbGRlciA9IGRhdGEuaG9sZGVyO1xuICAgICAgICBpZiAoKGlzVW5kZWZpbmVkKGhvbGRlcikgJiYgc2V0dGluZ3MpIHx8IHVwZGF0ZSkge1xuICAgICAgICAgICAgaG9sZGVyID0gbmV3IEF1dG9OdW1lcmljSG9sZGVyKCR0aGF0LmdldCgwKSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgZGF0YS5ob2xkZXIgPSBob2xkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBlRGVjICYgblNlcCBvcHRpb25zIGFyZSBiZWluZyB1c2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2VlcE9yaWdpbmFsU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgc2V0dGluZ3Mub0RlYyAgICAgPSBzZXR0aW5ncy5tRGVjO1xuICAgICAgICBzZXR0aW5ncy5vUGFkICAgICA9IHNldHRpbmdzLmFQYWQ7XG4gICAgICAgIHNldHRpbmdzLm9CcmFja2V0ID0gc2V0dGluZ3MubkJyYWNrZXQ7XG4gICAgICAgIHNldHRpbmdzLm9TZXAgICAgID0gc2V0dGluZ3MuYVNlcDtcbiAgICAgICAgc2V0dGluZ3Mub1NpZ24gICAgPSBzZXR0aW5ncy5hU2lnbjtcbiAgICAgICAgc2V0dGluZ3Mub1N1ZmZpeCAgPSBzZXR0aW5ncy5hU3VmZml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBlRGVjICYgblNlcCBvcHRpb25zIGFyZSBiZWluZyB1c2VkXG4gICAgICogdGFrZW4gZnJvbSBRdWlya3Ntb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhZENvb2tpZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWVFUSA9IG5hbWUgKyAnPSc7XG4gICAgICAgIGNvbnN0IGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGxldCBjID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHNlc3Npb25TdG9yYWdlIGlzIHN1cHBvcnRlZCAtIHRha2VuIGZyb20gbW9kZXJuaXpyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmFnZVRlc3QoKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9ICdtb2Rlcm5penInO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShtb2QsIG1vZCk7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKG1vZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBvciByZW1vdmVzIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZSBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCB0b0RvKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkTmFtZSA9ICgkdGhpc1swXS5uYW1lICE9PSAnJyAmJiAhaXNVbmRlZmluZWQoJHRoaXNbMF0ubmFtZSkpID9gQVVUT18ke2RlY29kZVVSSUNvbXBvbmVudCgkdGhpc1swXS5uYW1lKX1gIDpgQVVUT18keyR0aGlzWzBdLmlkfWA7XG4gICAgICAgICAgICBsZXQgZGF0ZTtcbiAgICAgICAgICAgIGxldCBleHBpcmVzO1xuXG4gICAgICAgICAgICAvLyBzZXRzIGNvb2tpZSBmb3IgYnJvd3NlciB0aGF0IGRvIG5vdCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlIElFIDYgJiBJRSA3XG4gICAgICAgICAgICBpZiAoc3RvcmFnZVRlc3QoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvRG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PSR7c2V0dGluZ3MucmF3VmFsdWV9OyBleHBpcmVzPSA7IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgtMSAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIE5vdGUgOiBgdG9HTVRTdHJpbmcoKWAgaGFzIGJlZW4gZGVwcmVjYXRlZCAoY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9HTVRTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0nJyA7JHtleHBpcmVzfTsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb29raWUoc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvRG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmVkTmFtZSwgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9sZGVyIG9iamVjdCBmb3IgZmllbGQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1dG9OdW1lcmljSG9sZGVyKHRoYXQsIHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICAgICAgdGhpcy4kdGhhdCA9ICQodGhhdCk7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NDbG9uZSA9IGF1dG9Db2RlKHRoaXMuJHRoYXQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhhdC52YWx1ZTtcbiAgICB9XG5cbiAgICBBdXRvTnVtZXJpY0hvbGRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGluaXQoZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NDbG9uZSA9IGF1dG9Db2RlKHRoaXMuJHRoYXQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5jdHJsS2V5ID0gZS5jdHJsS2V5O1xuICAgICAgICAgICAgdGhpcy5jbWRLZXkgPSBlLm1ldGFLZXk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcblxuICAgICAgICAgICAgLy8ga2V5cHJlc3MgZXZlbnQgb3ZlcndyaXRlcyBtZWFuaW5nZnVsIHZhbHVlIG9mIGUua2V5Q29kZVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBnZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCk7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZENvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndoaWNoID0gZS53aGljaDtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFNlbGVjdGlvbihzdGFydCwgZW5kLCBzZXRSZWFsKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgdGhpcy50aGF0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2V0UmVhbCkgfHwgc2V0UmVhbCkge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRQb3NpdGlvbihwb3MsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHBvcywgcG9zLCBzZXRSZWFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCZWZvcmVBZnRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdGhpcy5zZWxlY3Rpb24uc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB2YWx1ZS5zdWJzdHJpbmcodGhpcy5zZWxlY3Rpb24uZW5kLCB2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCZWZvcmVBZnRlclN0cmlwZWQoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyKCk7XG4gICAgICAgICAgICBsZWZ0ID0gYXV0b1N0cmlwKGxlZnQsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICByaWdodCA9IGF1dG9TdHJpcChyaWdodCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGxlZnQsICctJykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcbiAgICAgICAgICAgICAgICByaWdodCA9IChyaWdodCA9PT0gJy0nKSA/ICcnIDogcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0cmlwIHBhcnRzIGZyb20gZXhjZXNzIGNoYXJhY3RlcnMgYW5kIGxlYWRpbmcgemVyb2VzXG4gICAgICAgICAqL1xuICAgICAgICBub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICAgICAgLy8gcHJldmVudHMgbXVsdGlwbGUgbGVhZGluZyB6ZXJvcyBmcm9tIGJlaW5nIGVudGVyZWRcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgc2V0dGluZ3NDbG9uZSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHJpZ2h0IGlzIG5vdCBlbXB0eSBhbmQgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhRGVjLFxuICAgICAgICAgICAgcmlnaHQgPSBhdXRvU3RyaXAocmlnaHQsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsZWZ0ID09PSAnJyB8fCBsZWZ0ID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpICYmIHNldHRpbmdzQ2xvbmUubFplcm8gPT09ICdkZW55Jykge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCA+ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQucmVwbGFjZSgvXjAqKFxcZCkvLCAnJDEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB6ZXJvIGlmIGhhcyBsZWFkaW5nIGRvdFxuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFEZWMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gdGhpcy5uZXdWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKGBeJHtzZXR0aW5nc0Nsb25lLmFOZWdSZWdBdXRvU3RyaXB9XFxcXCR7c2V0dGluZ3NDbG9uZS5hRGVjfWApKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKG1bMV0sIG1bMV0gKyAnMCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBwYXJ0IG9mIG51bWJlciB0byB2YWx1ZSBrZWVwaW5nIHBvc2l0aW9uIG9mIGN1cnNvclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCwgYWR2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLm5vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHBhcnRzWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcblxuICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSB0cnVuY2F0ZURlY2ltYWwodGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSwgYWR2ZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0VmFsdWUgPSAoY29udGFpbnModGhpcy5uZXdWYWx1ZSwgJywnKSkgPyB0aGlzLm5ld1ZhbHVlLnJlcGxhY2UoJywnLCAnLicpIDogdGhpcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IHRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5uZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5ld1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhlbHBlciBmdW5jdGlvbiBmb3IgZXhwYW5kU2VsZWN0aW9uT25TaWduXG4gICAgICAgICAqIHJldHVybnMgc2lnbiBwb3NpdGlvbiBvZiBhIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lnblBvc2l0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGFTaWduID0gc2V0dGluZ3NDbG9uZS5hU2lnbjtcbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzLnRoYXQ7XG5cbiAgICAgICAgICAgIGlmIChhU2lnbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFTaWduTGVuID0gYVNpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTmVnID0gc2V0dGluZ3NDbG9uZS5hTmVnICYmIHRoYXQudmFsdWUgJiYgdGhhdC52YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc05lZyA/IFsxLCBhU2lnbkxlbiArIDFdIDogWzAsIGFTaWduTGVuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGF0LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbHVlTGVuIC0gYVNpZ25MZW4sIHZhbHVlTGVuXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFsxMDAwLCAtMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4cGFuZHMgc2VsZWN0aW9uIHRvIGNvdmVyIHdob2xlIHNpZ25cbiAgICAgICAgICogcHJldmVudHMgcGFydGlhbCBkZWxldGlvbi9jb3B5aW5nL292ZXJ3cml0aW5nIG9mIGEgc2lnblxuICAgICAgICAgKi9cbiAgICAgICAgZXhwYW5kU2VsZWN0aW9uT25TaWduKHNldFJlYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25Qb3NpdGlvbiA9IHRoaXMuc2lnblBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcblxuICAgICAgICAgICAgLy8gaWYgc2VsZWN0aW9uIGNhdGNoZXMgc29tZXRoaW5nIGV4Y2VwdCBzaWduIGFuZCBjYXRjaGVzIG9ubHkgc3BhY2UgZnJvbSBzaWduXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzFdICYmIHNlbGVjdGlvbi5lbmQgPiBzaWduUG9zaXRpb25bMF0pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHNlbGVjdCB3aXRob3V0IGVtcHR5IHNwYWNlXG4gICAgICAgICAgICAgICAgaWYgKChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0gfHwgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblsxXSkgJiYgdGhpcy52YWx1ZS5zdWJzdHJpbmcoTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1pbihzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pKS5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0sIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2lnblBvc2l0aW9uWzFdLCBzZWxlY3Rpb24uZW5kLCBzZXRSZWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugc2VsZWN0IHdpdGggd2hvbGUgc2lnblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihNYXRoLm1pbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWF4KHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSksIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSB0byBkaWdpdHNcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrUGFzdGUoKSB7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhcnRzID0gdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBzdHJpcCBwYXN0ZWQgdmFsdWUgZmlyc3RcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnQuc3Vic3RyKDAsIG9sZFBhcnRzWzBdLmxlbmd0aCkgKyBhdXRvU3RyaXAobGVmdC5zdWJzdHIob2xkUGFydHNbMF0ubGVuZ3RoKSwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2V0VmFsdWVQYXJ0cyhtb2RpZmllZExlZnRQYXJ0LCByaWdodCwgJ3Bhc3RlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9sZFBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBwYXN0aW5nLCBjdXJzb3IgbW92aW5nIGFuZCBza2lwcGluZyBvZiBub3QgaW50ZXJlc3Rpbmcga2V5c1xuICAgICAgICAgKiBpZiByZXR1cm5zIHRydWUsIGZ1cnRoZXIgcHJvY2Vzc2luZyBpcyBub3QgcGVyZm9ybWVkXG4gICAgICAgICAqL1xuICAgICAgICBza2lwQWx3YXlzKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGtkQ29kZSA9IHRoaXMua2RDb2RlO1xuICAgICAgICAgICAgY29uc3Qgd2hpY2ggPSB0aGlzLndoaWNoO1xuICAgICAgICAgICAgY29uc3QgY3RybEtleSA9IHRoaXMuY3RybEtleTtcbiAgICAgICAgICAgIGNvbnN0IGNtZEtleSA9IHRoaXMuY21kS2V5O1xuXG4gICAgICAgICAgICAvLyBjYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0S2V5ID0gdGhpcy5zaGlmdEtleTtcbiAgICAgICAgICAgIGlmICgoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiBlLnR5cGUgPT09ICdrZXl1cCcgJiYgIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkgfHwgKHNoaWZ0S2V5ICYmIGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBza2lwIEZ4IGtleXMsIHdpbmRvd3Mga2V5cywgb3RoZXIgc3BlY2lhbCBrZXlzXG4gICAgICAgICAgICBpZiAoKGtkQ29kZSA+PSBrZXlDb2RlLkYxICYmIGtkQ29kZSA8PSBrZXlDb2RlLkYxMikgfHxcbiAgICAgICAgICAgICAgICAoa2RDb2RlID49IGtleUNvZGUuV2luZG93cyAmJiBrZENvZGUgPD0ga2V5Q29kZS5SaWdodENsaWNrKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPj0ga2V5Q29kZS5UYWIgJiYga2RDb2RlIDwga2V5Q29kZS5TcGFjZSkgfHxcbiAgICAgICAgICAgICAgICAoa2RDb2RlIDwga2V5Q29kZS5CYWNrc3BhY2UgJiZcbiAgICAgICAgICAgICAgICAod2hpY2ggPT09IDAgfHwgd2hpY2ggPT09IGtkQ29kZSkpIHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLk51bUxvY2sgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuU2Nyb2xsTG9jayB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBzZWxlY3QgYWxsIChhKVxuICAgICAgICAgICAgaWYgKChjdHJsS2V5IHx8IGNtZEtleSkgJiYga2RDb2RlID09PSBrZXlDb2RlLmEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGlzLnRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU2lnbkxlbiA9IHRoaXMuc2V0dGluZ3MuYVNpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdMZW4gPSAoIWNvbnRhaW5zKHRoaXMudGhhdC52YWx1ZSwgJy0nKSk/MDoxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU3VmZml4TGVuID0gdGhpcy5zZXR0aW5ncy5hU3VmZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcFNpZ24gPSB0aGlzLnNldHRpbmdzLnBTaWduO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwTmVnID0gdGhpcy5zZXR0aW5ncy5wTmVnO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHBOZWcgPT09ICdsJyAmJiBuZWdMZW4gPT09IDEgJiYgYVNpZ25MZW4gPiAwKT9hU2lnbkxlbiArIDE6YVNpZ25MZW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBhU3VmZml4TGVuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwTmVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGFTdWZmaXhMZW4gKyBhU2lnbkxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoYVNpZ25MZW4gPiAwKT92YWx1ZUxlbiAtIChhU2lnbkxlbiArIG5lZ0xlbiArIGFTdWZmaXhMZW4pOnZhbHVlTGVuIC0gKGFTaWduTGVuICsgYVN1ZmZpeExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChhU2lnbkxlbiArIGFTdWZmaXhMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgY29weSAoYylcbiAgICAgICAgICAgIGlmICgoY3RybEtleSB8fCBjbWRLZXkpICYmIChrZENvZGUgPT09IGtleUNvZGUuYyB8fCBrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUueCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTZWxlY3Rpb25PblNpZ24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gcHJldmVudCB3cm9uZyBwYXN0ZVxuICAgICAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXN0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycgfHwga2RDb2RlID09PSBrZXlDb2RlLmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdHJsS2V5IHx8IGNtZEtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBqdW1wIG92ZXIgdGhvdXNhbmQgc2VwYXJhdG9yXG4gICAgICAgICAgICBpZiAoa2RDb2RlID09PSBrZXlDb2RlLkxlZnRBcnJvdyB8fCBrZENvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFTZXAgPSB0aGlzLnNldHRpbmdzQ2xvbmUuYVNlcDtcbiAgICAgICAgICAgICAgICBjb25zdCBhRGVjID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFEZWM7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRKdW1wID0gdGhpcy5zZWxlY3Rpb24uc3RhcnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRoYXQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nICYmICF0aGlzLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGFTZXAgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCAtIDIpID09PSBhRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzdGFydEp1bXAgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZENvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdyAmJiAodmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhU2VwIHx8IHZhbHVlLmNoYXJBdChzdGFydEp1bXAgKyAxKSA9PT0gYURlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oc3RhcnRKdW1wICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBrZENvZGUgPj0ga2V5Q29kZS5QYWdlRG93biAmJiBrZENvZGUgPD0ga2V5Q29kZS5Eb3duQXJyb3c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb2Nlc3MgZGVsZXRpb24gb2YgY2hhcmFjdGVycyB3aGVuIHRoZSBtaW51cyBzaWduIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzVHJhaWxpbmcoW2xlZnQsIHJpZ2h0XSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkgJiYgc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDEpID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmxlbmd0aCAtIHNldHRpbmdzQ2xvbmUuYVN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkgJiYgc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgKyBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgJy0nKSAmJiB0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmICgodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHx8ICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICsgc2V0dGluZ3NDbG9uZS5hTmVnLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICsgc2V0dGluZ3NDbG9uZS5hTmVnLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgdGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpIC0gc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnJyAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgJiYgc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAqIHJldHVybnMgdHJ1ZSBpZiBwcm9jZXNzaW5nIHBlcmZvcm1lZFxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0Fsd2F5cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0O1xuICAgICAgICAgICAgICAgIGxldCByaWdodDtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIChzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdsJyB8fCBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJykpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKHRoaXMudmFsdWUsICctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLnByb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTZWxlY3Rpb25PblNpZ24oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIGluc2VydGlvbiBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAqIHJldHVybnMgdHJ1ZSBpZiBwcm9jZXNzaW5nIHBlcmZvcm1lZFxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0tleXByZXNzKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGNDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLndoaWNoKTtcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHJ1bGVzIHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGtleSBpcyBwcmVzc2VkIGFsd2F5cyB1c2UgbnVtZXJpYyBwYWQgZG90IHRvIGluc2VydCBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG5vIGRlY2ltYWwgcGFydCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYURlYyB8fCAoc2V0dGluZ3NDbG9uZS5hbHREZWMgJiYgY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYWx0RGVjKSB8fCAoKGNDb2RlID09PSAnLicgfHwgY0NvZGUgPT09ICcsJykgJiYgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRG90TnVtcGFkKSkge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZS5tRGVjIHx8ICFzZXR0aW5nc0Nsb25lLmFEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGJlZm9yZSBhTmVnIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFOZWcgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG90aGVyIGRlY2ltYWwgY2hhcmFjdGVyIHByZXNlbnRcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hRGVjKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYURlYykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgc2V0dGluZ3NDbG9uZS5hRGVjLCByaWdodCwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJldmVudCBtaW51cyBpZiBub3QgYWxsb3dlZFxuICAgICAgICAgICAgaWYgKChjQ29kZSA9PT0gJy0nIHx8IGNDb2RlID09PSAnKycpICYmIHNldHRpbmdzQ2xvbmUuYU5lZyA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhcmV0IGlzIGFsd2F5cyBhZnRlciBtaW51c1xuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnKSB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHNpZ24gb2YgbnVtYmVyLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSAnLScgfHwgY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2Ugc2lnbiBvZiBudW1iZXIsIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRyeSB0byBpbnNlcnQgZGlnaXQgYmVmb3JlIG1pbnVzXG4gICAgICAgICAgICBpZiAoY0NvZGUgPj0gJzAnICYmIGNDb2RlIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFOZWcgJiYgbGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudk1heCA8PSAwICYmIHNldHRpbmdzQ2xvbmUudk1pbiA8IHNldHRpbmdzQ2xvbmUudk1heCAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSAmJiBjQ29kZSAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCArIGNDb2RlLCByaWdodCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHByZXZlbnQgYW55IG90aGVyIGNoYXJhY3RlclxuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmb3JtYXR0aW5nIG9mIGp1c3QgcHJvY2Vzc2VkIHZhbHVlIHdpdGgga2VlcGluZyBvZiBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGZvcm1hdFF1aWNrKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBsZWZ0TGVuZ3RoID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGt1Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgIGxldCBbbGVmdF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuXG4gICAgICAgICAgICAvLyBubyBncm91cGluZyBzZXBhcmF0b3IgYW5kIG5vIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5hU2VwICA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuYVNlcCAhPT0gJycgICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmFTZXApKSkgJiZcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5hU2lnbiA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuYVNpZ24gIT09ICcnICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmFTaWduKSkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IFtzdWJQYXJ0c10gPSBsZWZ0TGVuZ3RoLnNwbGl0KHNldHRpbmdzQ2xvbmUuYURlYyk7XG4gICAgICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHN1YlBhcnRzLCAnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5TaWduID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICBzdWJQYXJ0cyA9IHN1YlBhcnRzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludFBvcyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50TmVnICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlZnQgPSBuU2lnbiArIGxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXV0b0dyb3VwKHRoaXMudmFsdWUsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIHJlZ2V4cCB3aGljaCBzZWFyY2hlcyBmb3IgY3Vyc29yIHBvc2l0aW9uIGZyb20gdW5mb3JtYXR0ZWQgbGVmdCBwYXJ0XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEFyID0gbGVmdC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXhlcyBjYXJldCBwb3NpdGlvbiB3aXRoIHRyYWlsaW5nIG1pbnVzIHNpZ25cbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnICE9PSAncCcpKSAmJiBsZWZ0QXJbMF0gPT09ICctJyAmJiBzZXR0aW5nc0Nsb25lLmFOZWcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRBci5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ2wnICYmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBrdUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiYgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKGUudHlwZSA9PT0gJ2tleWRvd24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnICYmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBrdUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiYgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKGUudHlwZSA9PT0gJ2tleWRvd24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InICYmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBrdUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiYgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnblBhcnRzID0gc2V0dGluZ3NDbG9uZS5hU2lnbi5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVDaHIgPSBbJ1xcXFwnLCAnXicsICckJywgJy4nLCAnfCcsICc/JywgJyonLCAnKycsICcoJywgJyknLCAnWyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlZFBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goc2lnblBhcnRzLCAoaSwgbWluaVBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaVBhcnRzID0gc2lnblBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkobWluaVBhcnRzLCBlc2NhcGVDaHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKCdcXFxcJyArIG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2gobWluaVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1c2hpbmcgdGhlIGVzY2FwZWQgc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goZXNjYXBlZFBhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKGUudHlwZSA9PT0gJ2tleWRvd24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVmdEFyW2ldLm1hdGNoKCdcXFxcZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXJbaV0gPSAnXFxcXCcgKyBsZWZ0QXJbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UmVnID0gbmV3IFJlZ0V4cCgnXi4qPycgKyBsZWZ0QXIuam9pbignLio/JykpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIGN1cnNvciBwb3NpdGlvbiBpbiBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMZWZ0ID0gdmFsdWUubWF0Y2gobGVmdFJlZyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdMZWZ0WzBdLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUganVzdCBiZWZvcmUgc2lnbiB3aGljaCBpcyBpbiBwcmVmaXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgocG9zaXRpb24gPT09IDAgJiYgdmFsdWUuY2hhckF0KDApICE9PSBzZXR0aW5nc0Nsb25lLmFOZWcpIHx8IChwb3NpdGlvbiA9PT0gMSAmJiB2YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykpICYmIHNldHRpbmdzQ2xvbmUuYVNpZ24gJiYgc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSBjYXJldCBhZnRlciBwcmVmaXggc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoICsgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYVNpZ24gJiYgc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzaWduIGFzIGEgc3VmZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSBjYXJldCBiZWZvcmUgc3VmZml4IGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5hU3VmZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGhhdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZmFjdG9yaXNlIHRoZSBgZ2V0U3RyaW5nKClgIGFuZCBgZ2V0QXJyYXkoKWAgZnVuY3Rpb25zIHNpbmNlIHRoZXkgc2hhcmUgcXVpdGUgYSBsb3Qgb2YgY29kZS5cbiAgICAgKlxuICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICogVGhlIFwiZ2V0QXJyYXlcIiBtZXRob2Qgb24gdGhlIG90aGVyIGhhbmQgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplQXJyYXkoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9yIG9iamVjdHMgdGhhdCBjYW4gYmUgZW5jb2RlZCBhcyBhIEpTT04gc3RyaW5nLlxuICAgICAqXG4gICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwibG9jYWxlT3V0cHV0XCIgZm9yIGRldGFpbHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2V0QXJyYXlCZWhhdmlvciAtIElmIHNldCB0byBUUlVFLCB0aGVuIHRoaXMgZnVuY3Rpb24gYmVoYXZlIGxpa2UgYGdldEFycmF5KClgLCBvdGhlcndpc2UgaWYgc2V0IHRvIEZBTFNFLCBpdCBiZWhhdmUgbGlrZSBgZ2V0U3RyaW5nKClgXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZ2V0U3RyaW5nT3JBcnJheShnZXRBcnJheUJlaGF2aW9yID0gdHJ1ZSwgdGhhdCkge1xuICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGF0KSk7XG4gICAgICAgIGNvbnN0IGZvcm1JbmRleCA9ICQoJ2Zvcm0nKS5pbmRleCgkdGhpcyk7XG4gICAgICAgIGNvbnN0IGFsbEZvcm1FbGVtZW50cyA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KWApWzBdO1xuICAgICAgICBjb25zdCBhaUluZGV4ID0gW107XG5cbiAgICAgICAgLy8gYWxsIGlucHV0IGluZGV4XG4gICAgICAgIGNvbnN0IHNjSW5kZXggPSBbXTtcblxuICAgICAgICAvLyBzdWNjZXNzZnVsIGNvbnRyb2wgaW5kZXhcbiAgICAgICAgY29uc3QgclN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pO1xuXG4gICAgICAgIC8vIGZyb20galF1ZXJ5IHNlcmlhbGl6ZSBtZXRob2RcbiAgICAgICAgY29uc3QgclN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG4gICAgICAgIC8vIGZyb20galF1ZXJ5IHNlcmlhbGl6ZSBtZXRob2RcbiAgICAgICAgY29uc3QgckNoZWNrYWJsZVR5cGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaTtcbiAgICAgICAgY29uc3Qgck5vbkF1dG9OdW1lcmljVHlwZXMgPSAvXig/OmJ1dHRvbnxjaGVja2JveHxjb2xvcnxkYXRlfGRhdGV0aW1lfGRhdGV0aW1lLWxvY2FsfGVtYWlsfGZpbGV8aW1hZ2V8bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhZGlvfHJhbmdlfHJlc2V0fHNlYXJjaHxzdWJtaXR8dGltZXx1cmx8d2VlaykvaTtcblxuICAgICAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgICAgIC8vIGluZGV4IG9mIHN1Y2Nlc3NmdWwgZWxlbWVudHNcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSAhPT0gJycgJiYgclN1Ym1pdHRhYmxlLnRlc3QoZmllbGQubG9jYWxOYW1lKSAmJiAhclN1Ym1pdHRlclR5cGVzLnRlc3QoZmllbGQudHlwZSkgJiYgIWZpZWxkLmRpc2FibGVkICYmIChmaWVsZC5jaGVja2VkIHx8ICFyQ2hlY2thYmxlVHlwZS50ZXN0KGZpZWxkLnR5cGUpKSkge1xuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaChjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaW5kZXggb2YgYWxsIGlucHV0cyB0YWdzIGV4Y2VwdCBjaGVja2JveFxuICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiAoZmllbGQudHlwZSA9PT0gJycgfHwgZmllbGQudHlwZSA9PT0gJ3RleHQnIHx8IGZpZWxkLnR5cGUgPT09ICdoaWRkZW4nIHx8IGZpZWxkLnR5cGUgPT09ICd0ZWwnKSkge1xuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaChjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKC0xKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIHJOb25BdXRvTnVtZXJpY1R5cGVzLnRlc3QoZmllbGQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChnZXRBcnJheUJlaGF2aW9yKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplQXJyYXkoKTtcblxuICAgICAgICAgICAgJC5lYWNoKGZvcm1GaWVsZHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9ICQuaW5BcnJheShpLCBzY0luZGV4KTtcblxuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC52YWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0Jywgc2V0dGluZ3MubG9jYWxlT3V0cHV0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtRmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2V0U3RyaW5nKCkgYmVoYXZpb3JcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1QYXJ0cyA9IGZvcm1GaWVsZHMuc3BsaXQoJyYnKTtcblxuICAgICAgICAgICAgJC5lYWNoKGZvcm1QYXJ0cywgaSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2lucHV0TmFtZSwgaW5wdXRWYWx1ZV0gPSBmb3JtUGFydHNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSAkLmluQXJyYXkoaSwgc2NJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIGEgdmFsaWQgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkSW5wdXRWYWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0Jywgc2V0dGluZ3MubG9jYWxlT3V0cHV0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1QYXJ0c1tpXSA9IGAke2lucHV0TmFtZX09JHttb2RpZmllZElucHV0VmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybVBhcnRzLmpvaW4oJyYnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdmb2N1c2luJyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSBob2xkZXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkZvY3VzSW4oJHRoaXMsIGhvbGRlcikge1xuICAgICAgICAkdGhpcy5vbignZm9jdXNpbi5hdXRvTnVtZXJpYycsICgpID0+IHtcbiAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgICRzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICgkc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgJHNldHRpbmdzLmFOZWcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMudmFsKG5lZ2F0aXZlQnJhY2tldCgkdGhpcy52YWwoKSwgJHNldHRpbmdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoJHNldHRpbmdzLmVEZWMpIHtcbiAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5lRGVjO1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgJHNldHRpbmdzLm1EZWMgPSAkc2V0dGluZ3Mub0RlYztcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHNldHRpbmdzLm5TZXApIHtcbiAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNlcCA9ICcnO1xuICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU3VmZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChyZXN1bHQgPSBhdXRvU3RyaXAoJHRoaXMudmFsKCksICRzZXR0aW5ncykpICE9PSAkc2V0dGluZ3MucmF3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG9sZGVyLmluVmFsID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGhvbGRlci5pblZhbDtcbiAgICAgICAgICAgIGNvbnN0IG9uRW1wdHkgPSBjaGVja0VtcHR5KGhvbGRlci5pblZhbCwgJHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICgob25FbXB0eSAhPT0gbnVsbCAmJiBvbkVtcHR5ICE9PSAnJykgJiYgJHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICR0aGlzLnZhbChvbkVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5ZG93bicgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcGFyYW0gaG9sZGVyXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25LZXlkb3duKCR0aGlzLCBob2xkZXIpIHtcbiAgICAgICAgJHRoaXMub24oJ2tleWRvd24uYXV0b051bWVyaWMnLCBlID0+IHtcbiAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICBpZiAoaG9sZGVyLnRoYXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogLy8gVGhlIGNvZGUgYmVsb3cgYWxsb3dzIHRoZSBcImVudGVyXCIga2V5ZG93biB0byB0aHJvdyBhIGNoYW5nZSgpIGV2ZW50XG4gICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0ga2V5Q29kZS5FbnRlciAmJiBob2xkZXIuaW5WYWwgIT09ICR0aGlzLnZhbCgpKSB7XG4gICAgICAgICAgICAgJHRoaXMuY2hhbmdlKCk7XG4gICAgICAgICAgICAgaG9sZGVyLmluVmFsID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgfSAqL1xuICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhvbGRlci5wcm9jZXNzQWx3YXlzKCkpIHtcbiAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0UXVpY2soZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50VmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93cyBpbnB1dCBldmVudCBpbiBkZWxldGlvbiBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5cHJlc3MnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICogQHBhcmFtIGhvbGRlclxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5cHJlc3MoJHRoaXMsIGhvbGRlcikge1xuICAgICAgICAkdGhpcy5vbigna2V5cHJlc3MuYXV0b051bWVyaWMnLCBlID0+IHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZml4IGZvciBTaGlmdCAmJiBpbnNlcnQgcGFzdGUgZXZlbnRcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5ICYmIGUua2V5Q29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gaG9sZGVyLnByb2Nlc3NlZDtcbiAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xuXG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhvbGRlci5wcm9jZXNzQWx3YXlzKCkgfHwgaG9sZGVyLnByb2Nlc3NLZXlwcmVzcygpKSB7XG4gICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvd3MgaW5wdXQgZXZlbnQgb24gYWRkaW5nIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2tleXVwJyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSBob2xkZXJcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleXVwKCR0aGlzLCBob2xkZXIsIHNldHRpbmdzKSB7XG4gICAgICAgICR0aGlzLm9uKCdrZXl1cC5hdXRvTnVtZXJpYycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICBob2xkZXIuaW5pdChlKTtcbiAgICAgICAgICAgIGNvbnN0IHNraXAgPSBob2xkZXIuc2tpcEFsd2F5cyhlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhYiA9IGhvbGRlci5rZENvZGU7XG4gICAgICAgICAgICBob2xkZXIua2RDb2RlID0gMDtcbiAgICAgICAgICAgIGRlbGV0ZSBob2xkZXIudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuXG5cdFx0XHQvLyBhZGRlZCB0byBwcm9wZXJseSBwbGFjZSB0aGUgY2FyZXQgd2hlbiBvbmx5IHRoZSBjdXJyZW5jeSBzaWduIGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmICgkdGhpc1swXS52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24pIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcywgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoLCBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFiID09PSBrZXlDb2RlLlRhYikge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcywgMCwgJHRoaXMudmFsKCkubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCR0aGlzWzBdLnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID09PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN1ZmZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzYXZlcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCB0byBwcmVzZXJ2ZSB0aGUgZGF0YSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlXG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZURlYyAhPT0gbnVsbCAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3Rvcikge1xuICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFob2xkZXIuZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNvdXQnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICogQHBhcmFtIGhvbGRlclxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRm9jdXNPdXQoJHRoaXMsIGhvbGRlcikge1xuICAgICAgICAkdGhpcy5vbignZm9jdXNvdXQuYXV0b051bWVyaWMnLCAoKSA9PiB7XG4gICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgJHNldHRpbmdzLm9uT2ZmID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoJHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsICRzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJHNldHRpbmdzLm5TZXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNlcCA9ICRzZXR0aW5ncy5vU2VwO1xuICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2lnbiA9ICRzZXR0aW5ncy5vU2lnbjtcbiAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVN1ZmZpeCA9ICRzZXR0aW5ncy5vU3VmZml4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJHNldHRpbmdzLmVEZWMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5vRGVjO1xuICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hUGFkID0gJHNldHRpbmdzLm9QYWQ7XG4gICAgICAgICAgICAgICAgJHNldHRpbmdzLm5CcmFja2V0ID0gJHNldHRpbmdzLm9CcmFja2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRW1wdHkodmFsdWUsICRzZXR0aW5ncykgPT09IG51bGwgJiYgbWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZml4TnVtYmVyKHZhbHVlLCAkc2V0dGluZ3MuYURlYywgJHNldHRpbmdzLmFOZWcpO1xuICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvICRzZXR0aW5ncy5zY2FsZURpdmlzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICRzZXR0aW5ncy5zY2FsZURlY2ltYWwpPyskc2V0dGluZ3Muc2NhbGVEZWNpbWFsOiRzZXR0aW5ncy5tRGVjO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCh2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3Mud0VtcHR5ID09PSAnemVybycpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnJhd1ZhbHVlID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCgnMCcsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZ3JvdXBlZFZhbHVlID0gY2hlY2tFbXB0eSh2YWx1ZSwgJHNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBvcmlnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSAoJHNldHRpbmdzLnNjYWxlU3ltYm9sKT9ncm91cGVkVmFsdWUgKyAkc2V0dGluZ3Muc2NhbGVTeW1ib2w6Z3JvdXBlZFZhbHVlO1xuICAgICAgICAgICAgICAgICR0aGlzLnZhbChncm91cGVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBob2xkZXIuaW5WYWwpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLmluVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdwYXN0ZScgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcGFyYW0gaG9sZGVyXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25QYXN0ZSgkdGhpcywgaG9sZGVyKSB7XG4gICAgICAgICR0aGlzLm9uKCdwYXN0ZScsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdC8vRklYTUUgQWZ0ZXIgYSBwYXN0ZSwgdGhlIGNhcmV0IGlzIHB1dCBvbiB0aGUgZmFyIHJpZ2h0IG9mIHRoZSBpbnB1dCwgaXQgc2hvdWxkIGJlIHNldCB0byBzb21ldGhpbmcgbGlrZSBgbmV3Q2FyZXRQb3NpdGlvbiA9IG9sZENhcmV0UG9zaXRpb24gKyBwYXN0ZVRleHQubGVuZ3RoO2AsIHdoaWxlIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMgYW5kIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcblxuICAgICAgICAgICAgY29uc3Qgb2xkUmF3VmFsdWUgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICBjb25zdCBzdWZmaXggPSBjdXJyZW50VmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvbkVuZCwgY3VycmVudFZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBwYXN0ZWRUZXh0ID0gcHJlcGFyZVBhc3RlZFRleHQoZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpLmhvbGRlcik7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkUGFzdGVUZXh0KHBhc3RlZFRleHQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwcmVwYXJlUGFzdGVkVGV4dChwcmVmaXggKyBOdW1iZXIocGFzdGVkVGV4dCkudmFsdWVPZigpICsgc3VmZml4LCBob2xkZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRQYXN0ZVRleHQobmV3VmFsdWUpICYmIE51bWJlcihvbGRSYXdWYWx1ZSkudmFsdWVPZigpICE9PSBOdW1iZXIobmV3VmFsdWUpLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnc3VibWl0JyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSBob2xkZXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblN1Ym1pdCgkdGhpcywgaG9sZGVyKSB7XG4gICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGhvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy51blNldE9uU3VibWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGpRdWVyeSBzZWxlY3RlZCBpbnB1dCBpZiB0aGUgdGFnIGFuZCB0eXBlIGFyZSBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnwqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKCR0aGlzKSB7XG4gICAgICAgIC8vIFN1cHBvcnRlZCBpbnB1dCB0eXBlXG4gICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcblxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgaW5wdXQgdHlwZXNcbiAgICAgICAgaWYgKCEkaW5wdXQgJiYgJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBpbnB1dCB0eXBlIFwiJHskdGhpcy5wcm9wKCd0eXBlJyl9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGZvciBub24tc3VwcG9ydGVkIHRhZ3NcbiAgICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRUYWcgPSAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VGFnICE9PSAnaW5wdXQnICYmICFpc0luQXJyYXkoY3VycmVudEVsZW1lbnRUYWcsIGFsbG93ZWRUYWdMaXN0KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIDwke2N1cnJlbnRFbGVtZW50VGFnfT4gdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkaW5wdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91dGluZSB0byBmb3JtYXQgdGhlIGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0gJGlucHV0XG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChzZXR0aW5ncywgJGlucHV0LCAkdGhpcykge1xuICAgICAgICBsZXQgc2V0VmFsdWUgPSB0cnVlO1xuXG4gICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBoYXMgYmVlbiBzZXQgYnkgdGhlIGRldiwgYnV0IG5vdCBkaXJlY3RseSBhcyBhbiBhdHRyaWJ1dGUgaW4gdGhlIGh0bWwsIHRoZW4gaXQgdGFrZXNcbiAgICAgICAgICAgICAqIHByZWNlZGVuY2UgYW5kIHNob3VsZCBnZXQgZm9ybWF0dGVkIG9uIGluaXQgKGlmIHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXG4gICAgICAgICAgICAgKiBkZXZlbG9wZXIgd2FudHMgaXQgZm9ybWF0dGVkIG9uIGluaXQgKGNmLiBgc2V0dGluZ3MuYUZvcm1gKSkuXG4gICAgICAgICAgICAgKiBOb3RlOyB0aGlzIGlzIHRydWUgd2hhdGV2ZXIgdGhlIGRldmVsb3BlciBoYXMgc2V0IGZvciBgZGF0YS1hbi1kZWZhdWx0YCBpbiB0aGUgaHRtbCAoYXNwLm5ldCB1c2VycykuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3RoZXIgd29yZHMgOiBpZiBgYW5EZWZhdWx0YCBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcHJldmVudCBwb3N0YmFjayBwcm9ibGVtcy5cbiAgICAgICAgICAgICAqIEJ1dCBpZiBgaW5wdXQudmFsdWVgIGlzIHNldCB0byBhIG51bWJlciwgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LCB0aGVuIGl0IG1lYW5zIHRoZSBkZXYgaGFzXG4gICAgICAgICAgICAgKiBjaGFuZ2VkIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIHRoZW4gaXQgbWVhbnMgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaGlzIG93biBkZWNpc2lvbiB0byBkbyBzby5cbiAgICAgICAgICAgICAqIEhlbmNlLCBpZiBgYW5EZWZhdWx0YCBpcyBub3QgbnVsbCwgYnV0IGBpbnB1dC52YWx1ZWAgaXMgYSBudW1iZXIgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LFxuICAgICAgICAgICAgICogd2Ugc2hvdWxkIGlnbm9yZSBgYW5EZWZhdWx0YCBhbHRvZ2V0aGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYUZvcm0gJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoJHRoaXMuYXR0cigndmFsdWUnKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCBvciBub3RcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ZWRDdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPIFJlcGxhY2Ugd2hhdGV2ZXIgbG9jYWxlIGNoYXJhY3RlciBpcyB1c2VkIGJ5IGEgJy4nLCBhbmQgbm90IG9ubHkgdGhlIGNvbW1hICcsJ1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odGVzdGVkQ3VycmVudFZhbHVlKSAmJiBJbmZpbml0eSAhPT0gdGVzdGVkQ3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCB0ZXN0ZWRDdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7Y3VycmVudFZhbHVlfV0gdXNlZCBpbiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgdmFsdWUgYXV0b051bWVyaWMgY2FuIHdvcmsgd2l0aC5gLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBDaGVja3MgZm9yIDpcbiAgICAgICAgICAgICAgICAgKiAtIHBhZ2UgcmVsb2FkIGZyb20gYmFjayBidXR0b24sIGFuZFxuICAgICAgICAgICAgICAgICAqIC0gQVNQLm5ldCBmb3JtIHBvc3QgYmFja1xuICAgICAgICAgICAgICAgICAqICAgICAgVGhlIGZvbGxvd2luZyBIVE1MIGRhdGEgYXR0cmlidXRlIGlzIFJFUVVJUkVEIChkYXRhLWFuLWRlZmF1bHQ9XCJzYW1lIHZhbHVlIGFzIHRoZSB2YWx1ZSBhdHRyaWJ1dGVcIilcbiAgICAgICAgICAgICAgICAgKiAgICAgIGV4YW1wbGU6IDxhc3A6VGV4dEJveCBydW5hdD1cInNlcnZlclwiIGlkPVwic29tZUlEXCIgdGV4dD1cIjEyMzQuNTZcIiBkYXRhLWFuLWRlZmF1bHQ9XCIxMjM0LjU2XCI+XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy9UT0RPIFJlcGxhY2Ugd2hhdGV2ZXIgbG9jYWxlIGNoYXJhY3RlciBpcyB1c2VkIGJ5IGEgJy4nLCBhbmQgbm90IG9ubHkgdGhlIGNvbW1hICcsJywgYmFzZWQgb24gdGhlIGxvY2FsZSB1c2VkIGJ5IHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5hbkRlZmF1bHQgIT09IG51bGwgJiYgc2V0dGluZ3MuYW5EZWZhdWx0LnRvU3RyaW5nKCkgIT09IGN1cnJlbnRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLmFuRGVmYXVsdCA9PT0gbnVsbCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGN1cnJlbnRWYWx1ZSAhPT0gJHRoaXMuYXR0cigndmFsdWUnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgJHRoaXMuYXR0cigndHlwZScpID09PSAnaGlkZGVuJyAmJiAhJC5pc051bWVyaWMoY3VycmVudFZhbHVlLnJlcGxhY2UoJywnLCAnLicpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5lRGVjICE9PSBudWxsICYmIHNldHRpbmdzLmFTdG9yKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5hU3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZURlYyB2YWx1ZSBzaG91bGQgTk9UIGJlIHNhdmVkIGluIHNlc3Npb25TdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b1N0cmlwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IG5lZ2F0aXZlQnJhY2tldChjdXJyZW50VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAoKHNldHRpbmdzLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3MucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5ncy5wTmVnICE9PSAncCcpKSAmJiBzZXR0aW5ncy5hTmVnICE9PSAnJyAmJiBjb250YWlucyhjdXJyZW50VmFsdWUsICctJykpPyctJyArIGF1dG9TdHJpcCh0b1N0cmlwLCBzZXR0aW5ncyk6YXV0b1N0cmlwKHRvU3RyaXAsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mud0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChzZXR0aW5ncy5hU2lnbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3plcm8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICcwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0VmFsdWUgJiYgY3VycmVudFZhbHVlID09PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSAmJiAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5EZWZhdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFuRGVmYXVsdCA9PT0gJHRoaXMudGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFseXNlIHRoZSBzZXR0aW5ncy9vcHRpb25zIHBhc3NlZCBieSB0aGUgdXNlciwgdmFsaWRhdGUgYW5kIGNsZWFuIHRoZW0sIHRoZW4gcmV0dXJuIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMpIHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBncmFiIFwiYXV0b051bWVyaWNcIiBzZXR0aW5ncy4gSWYgdGhleSBkbyBub3QgZXhpc3QsIGl0IHJldHVybnMgXCJ1bmRlZmluZWRcIi5cbiAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBncmFiIGFueSBzZXR0aW5ncywgY3JlYXRlIHRoZW0gZnJvbSB0aGUgZGVmYXVsdCBvbmVzIGFuZCBjb21iaW5lIHRoZW0gd2l0aCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBIVE1MNSBkYXRhLCBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3ZSdsbCBnZXQgXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgY29uc3QgdGFnRGF0YSA9ICR0aGlzLmRhdGEoKTtcblxuICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB0YWdEYXRhLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgb25PZmYgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcnVuT25jZSAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmF3VmFsdWUgICAgICAgIDogJycsXG4gICAgICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FyZXRGaXggICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGhyb3dJbnB1dCAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdHJpcCAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICA6IGFsbG93ZWRUYWdMaXN0LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgdXNlciBzZXR0aW5ncyB0byBtYWtlIHRoZW0gJ2V4cGxvaXRhYmxlJ1xuICAgICAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyAndHJ1ZScgYW5kICdmYWxzZScgdG8gcmVhbCBCb29sZWFuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IEJvb2xlYW4odmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBudW1iZXJzIGluIG9wdGlvbnMgdG8gc3RyaW5nc1xuICAgICAgICAgICAgICAgIC8vVE9ETyBpZiBhIHZhbHVlIGlzIG9mIHR5cGUgJ051bWJlcicsIHNob3VsZG4ndCB3ZSBrZWVwIGl0IGFzIGEgbnVtYmVyIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgaW5zdGVhZCBvZiB1c2luZyBhIHN0cmluZz9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBrZXkgIT09ICdhU2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc2V0dGluZ3NcbiAgICAgICAgICAgIHZhbGlkYXRlKHNldHRpbmdzLCBmYWxzZSk7IC8vIFRocm93cyBpZiBuZWNlc3NhcnlcblxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgbmV3IHNldHRpbmdzXG4gICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2RzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY1xuICAgICAqL1xuICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gaW5pdGlhdGUgYXV0b051bWVyaWMgYW5kIGF0dGFjaCB0aGUgc2V0dGluZ3MgKG9wdGlvbnMgY2FuIGJlIHBhc3NlZCBhcyBhIHBhcmFtZXRlcilcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHthU2VwOiBcIi5cIiwgYURlYzogXCIsXCIsIGFTaWduOiAn4oKsICd9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnKTsgICAgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygpOyAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jywge29wdGlvbnN9KTsgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyh7b3B0aW9uc30pOyAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCAkaW5wdXQgPSBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgkdGhpcyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldEluaXRpYWxTZXR0aW5ncyhvcHRpb25zLCAkdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMsIHNjYWxlRGl2aXNvciAmIG5TZXAgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxuICAgICAgICAgICAgICAgIGtlZXBPcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBsZXQgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICAvL1RPRE8gU2hvdWxkbid0IHRoZSBuZXh0IGxpbmUgYmUgaW4gdGhlIGBnZXRJbml0aWFsU2V0dGluZ3MoKWAgZnVuY3Rpb24/XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSA9PT0gZmFsc2UgJiYgc2V0dGluZ3MuYUZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChzZXR0aW5ncywgJGlucHV0LCAkdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucnVuT25jZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGV2ZW50cyBsaXN0ZW5lcnMgdG8gc3VwcG9ydGVkIGlucHV0IHR5cGVzIChcInRleHRcIiwgXCJoaWRkZW5cIiwgXCJ0ZWxcIiBhbmQgbm8gdHlwZSlcbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IG9uRm9jdXNJbigkdGhpcywgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25Gb2N1c091dCgkdGhpcywgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25LZXlkb3duKCR0aGlzLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBvbktleXByZXNzKCR0aGlzLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBvbktleXVwKCR0aGlzLCBob2xkZXIsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25QYXN0ZSgkdGhpcywgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgb25TdWJtaXQoJHRoaXMsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byByZW1vdmUgc2V0dGluZ3MgYW5kIHN0b3AgYXV0b051bWVyaWMoKSAtIGRvZXMgbm90IHJlbW92ZSB0aGUgZm9ybWF0dGluZ1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJkZXN0cm95XCIpOyAvLyBkZXN0cm95cyBhdXRvTnVtZXJpY1xuICAgICAgICAgKiBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlRGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub2ZmKCcuYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIGNsZWFyIHRoZSB2YWx1ZSBhbmQgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcIndpcGVcIik7IC8vIHJlbW92ZXMgc2Vzc2lvbiBzdG9yYWdlIGFuZCBjb29raWVzIGZyb20gbWVtb3J5XG4gICAgICAgICAqIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHdpcGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdGhhdCB1cGRhdGVzIHRoZSBhdXRvTnVtZXJpYyBzZXR0aW5nc1xuICAgICAgICAgKiBJdCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGlmIG5lZWRlZFxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2FTZXA6IFwiLlwiLCBhRGVjOiBcIixcIiwgYVNpZ246ICfigqwgJ30pXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ1cGRhdGVcIiwge29wdGlvbnN9KTsgLy8gdXBkYXRlcyB0aGUgc2V0dGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwidXBkYXRlXCIgbWV0aG9kYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmlwID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gKHNldHRpbmdzLnNjYWxlRGVjaW1hbCkgPyBzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiBzZXR0aW5ncy5tRGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZWVwT3JpZ2luYWxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgZ2V0SG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyA9PT0gc2V0dGluZ3MuYVNlcCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBhRGVjOiBcIiR7c2V0dGluZ3MuYURlY31cIiBhbmQgdGhvdXNhbmQgc2VwYXJhdG9yIGFTZXA6IFwiJHtzZXR0aW5ncy5hU2VwfVwiIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXJgLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCR0aGlzLnZhbCgpICE9PSAnJyB8fCAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc3RyaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gZm9ybWF0IHRoZSB2YWx1ZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnc2V0JywgJ3ZhbHVlJyk7IC8vIGZvcm1hdHMgdGhlIHZhbHVlIGJlaW5nIHBhc3NlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlclxuICAgICAgICAgKiBJZiB0aGUgdmFsdWUgaXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBpdCBjYW4gYmUgYW4gaW50ZWdlciAnMTIzNCcgb3IgYSBkb3VibGUgJzEyMzQuNTY3ODknXG4gICAgICAgICAqIGFuZCBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzIGFuZCBvbmUgZGVjaW1hbCAocGVyaW9kKSBjaGFyYWN0ZXJcbiAgICAgICAgICovXG4gICAgICAgIHNldCh2YWx1ZUluKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZUluID09PSBudWxsIHx8IGlzVW5kZWZpbmVkKHZhbHVlSW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVJbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcInNldFwiIG1ldGhvZGAsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFsbG93cyBsb2NhbGUgZGVjaW1hbCBzZXBhcmF0b3IgdG8gYmUgYSBjb21tYSAtIG5vIHRob3VzYW5kIHNlcGFyYXRvciBhbGxvd2VkXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmcm9tTG9jYWxlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgYmVpbmcgc2V0IGlzIG5vdCBudW1lcmljXG4gICAgICAgICAgICAgICAgaWYgKCEkLmlzTnVtZXJpYyhOdW1iZXIodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nIFwic2V0XCIgaXMgbm90IG51bWVyaWMgYW5kIGhhcyBjYXVzZWQgYSBlcnJvciB0byBiZSB0aHJvd25gLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQgJiYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gbWF4IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0IHx8IGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVEaXZpc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgPT09IG51bGwgJiYgc2V0dGluZ3Muc2NhbGVEaXZpc29yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVN0b3IgJiYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7YXR0ZW1wdGVkVmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSB0aGUgdk1pbiBbJHtzZXR0aW5ncy52TWlufV0gYW5kIHZNYXggWyR7c2V0dGluZ3Mudk1heH1dIHNldHRpbmdzIGZvciB0aGlzIGVsZW1lbnRgLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub25PZmYgJiYgc2V0dGluZ3Muc2NhbGVTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArIHNldHRpbmdzLnNjYWxlU3ltYm9sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byB1bi1mb3JtYXQgaW5wdXRzIC0gaGFuZHkgdG8gdXNlIHJpZ2h0IGJlZm9yZSBmb3JtIHN1Ym1pc3Npb25cbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCd1blNldCcpOyAvLyBubyBwYXJhbWV0ZXIgYWNjZXB0ZWRcbiAgICAgICAgICogYnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIGxvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwibG9jYWxlT3V0cHV0XCIgZm9yIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIHVuU2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byByZS1mb3JtYXQgaW5wdXRzIC0gaGFuZHkgdG8gdXNlIHJpZ2h0IGFmdGVyIGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3JlU2V0Jyk7IC8vIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICogdGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlICd1blNldCcgbWV0aG9kIHRvIHJlZm9ybWF0IHRoZSBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgcmVTZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnZhbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIGdldCB0aGUgdW5mb3JtYXR0ZWQgdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBwYXJhbWV0ZXJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXQnKTsgbm8gcGFyYW1ldGVyIHN1cHBvcnRlZFxuICAgICAgICAgKiBieSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogbG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgLy9UT0RPIENyZWF0ZSBhIGBnZXQoKWAgbWV0aG9kIHRoYXQgYWx3YXlzIHJldHVybiB0aGUgcmF3IHZhbHVlLCBubyBtYXR0ZXIgd2hhdCBgbG9jYWxlT3V0cHV0YCBpcy4gQ3JlYXRlIGEgYGdldFdpdGhMb2NhbGUoKWAgbWV0aG9kIHRoYXQgYmVoYXZlIGxpa2UgdGhlIGN1cnJlbnQgYGdldGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGNhbiBzb21ldGltZXMgcmV0dXJuIGEgbnVtYmVyLCBvciBhIHN0cmluZy4gRG9pbmcgc28gd2lsbCByZW1vdmUgdW5jZXJ0YWludHkgZm9yIGRldmVsb3BlcnMuXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIC8vVE9ETyBXaHkgd291bGQgd2UgbmVlZCB0byBnZXQgYSBuZXcgcmVmZXJlbmNlIHRvICR0aGlzIHNpbmNlIGl0IGhhcyBiZWVuIGRvbmUgaW4gYGluaXQoKWA/XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICAvL1RPRE8gVGhpcyBsb29rcyBhIGxvdCBsaWtlIGBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgpYC4gSXMgdGhhdCBuZWNlc3Nhcnk/IENhbiB0aGUgaW5wdXQgZWxlbWVudCBiZSBjaGFuZ2VkIHNpbmNlIGF1dG9OdW1lcmljIGhhcyBiZWVuIGluaXRpYWxpemVkP1xuICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJnZXRcIiBtZXRob2RgLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBlbGVtZW50IHR5cGUgdGhlbiB1c2UgLmVxKDApIHNlbGVjdG9yIHRvIGdyYWIgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHNlbGVjdG9yXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnZhbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAkdGhpcy5lcSgwKS50ZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBcIjwkeyR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpfT5cIiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2AsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKC9cXGQvKS50ZXN0KHZhbHVlKSB8fCBOdW1iZXIodmFsdWUpID09PSAwKSAmJiBzZXR0aW5ncy53RW1wdHkgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnICYmIHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZWdhdGl2ZUJyYWNrZXQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJ1bk9uY2UgfHwgc2V0dGluZ3MuYUZvcm0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1N0cmlwKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZml4TnVtYmVyKHZhbHVlLCBzZXR0aW5ncy5hRGVjLCBzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDAgJiYgc2V0dGluZ3MubFplcm8gIT09ICdrZWVwJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5sb2NhbGVPdXRwdXQpO1xuXG4gICAgICAgICAgICAvLyByZXR1cm5lZCBOdW1lcmljIFN0cmluZ1xuICAgICAgICAgICAgLy9UT0RPIFNob3VsZG4ndCB3ZSByZXR1cm4gYE51bWJlcih2YWx1ZSlgIHNpbmNlIHRoZSBnb2FsIG9mIGBnZXRgIGlzIHRvIGdldCB0aGUgcmF3IGphdmFzY3JpcHQgdmFsdWU/IC0+IHRoYXQgY291bGQgZGVwZW5kIG9uIGBsb2NhbGVPdXRwdXRgXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgY3VycmVudCBmb3JtYXR0ZWQgdmFsdWUgb2YgdGhlIGF1dG9OdW1lcmljIGVsZW1lbnQuXG4gICAgICAgICAqIEB1c2FnZSBhTklucHV0LmF1dG9OdW1lcmljKCdnZXRGb3JtYXR0ZWQnKSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEZvcm1hdHRlZCgpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBgdGhpc1swXWAgZXhpc3RzIGFzIHdlbGwgYXMgYC52YWx1ZWAgYmVmb3JlIHRyeWluZyB0byBhY2Nlc3MgdGhhdCBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCcwJykgfHwgISgndmFsdWUnIGluIHRoaXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcignVW5hYmxlIHRvIGdldCB0aGUgZm9ybWF0dGVkIHN0cmluZyBmcm9tIHRoZSBlbGVtZW50LicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXS52YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRTdHJpbmdPckFycmF5KGZhbHNlLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFwiZ2V0QXJyYXlcIiBtZXRob2Qgb24gdGhlIG90aGVyIGhhbmQgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplQXJyYXkoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9yIG9iamVjdHMgdGhhdCBjYW4gYmUgZW5jb2RlZCBhcyBhIEpTT04gc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXG4gICAgICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRBcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheSh0cnVlLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlICdnZXRTZXR0aW5ncycgZnVuY3Rpb24gcmV0dXJucyB0aGUgb2JqZWN0IHdpdGggYXV0b051bWVyaWMgc2V0dGluZ3MgZm9yIHRob3NlIHdobyBuZWVkIHRvIGxvb2sgdW5kZXIgdGhlIGhvb2RcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRTZXR0aW5ncycpOyAvLyBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKS5hRGVjOyAvLyByZXR1cm4gdGhlIGFEZWMgc2V0dGluZyBhcyBhIHN0cmluZyAtIGFudCB2YWxpZCBzZXR0aW5nIGNhbiBiZSB1c2VkXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuICR0aGlzLmVxKDApLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhdXRvTnVtZXJpYyBmdW5jdGlvbiBhY2NlcHRzIG1ldGhvZHMgbmFtZXMgKGluIHN0cmluZyBmb3JtYXQpIGFuZCB0aG9zZSBtZXRob2QgcGFyYW1ldGVycyBpZiBuZWVkZWQuXG4gICAgICogSXQgaW5pdGlhbGl6ZSBhdXRvTnVtZXJpYyBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKi9cbiAgICAkLmZuLmF1dG9OdW1lcmljID0gZnVuY3Rpb24obWV0aG9kLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChtZXRob2RzW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcgfHwgIW1ldGhvZCkge1xuICAgICAgICAgICAgLy8gVGhlIG9wdGlvbnMgaGF2ZSBiZWVuIHBhc3NlZCBkaXJlY3RseSwgd2l0aG91dCB1c2luZyBhIG5hbWVkIG1ldGhvZFxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSh0aGlzLCBbbWV0aG9kXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd0Vycm9yKGBNZXRob2QgXCIke21ldGhvZH1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGVmYXVsdCBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0Q29uZmlnID0gKCkgPT4gZGVmYXVsdFNldHRpbmdzO1xuXG4gICAgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cyA9IGRlZmF1bHRTZXR0aW5nczsgLy8gTWFrZSB0aG9zZSBzZXR0aW5ncyBwdWJsaWMgdmlhIGpRdWVyeSB0b28uXG5cbiAgICAvKipcbiAgICAgKiBwdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnQgdHJpZ2dlclxuICAgICAqL1xuICAgIGF1dG9Gb3JtYXQgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIodmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB2TWF4ID0gc2V0dGluZ3Mudk1heC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBjb25zdCB2TWluID0gKCFzZXR0aW5ncy52TWluICYmIHNldHRpbmdzLnZNaW4gIT09IDApID8gW10gOiBzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBkZWNMZW5ndGgodk1pbiwgdk1heCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgaWYgKCFtaW5UZXN0IHx8ICFtYXhUZXN0KSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhIGN1c3RvbSBldmVudFxuICAgICAgICAgICAgc2VuZEN1c3RvbUV2ZW50KCdhdXRvRm9ybWF0LmF1dG9OdW1lcmljJywgYFJhbmdlIHRlc3QgZmFpbGVkYCk7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSB0aGUgdk1pbiBbJHtzZXR0aW5ncy52TWlufV0gYW5kIHZNYXggWyR7c2V0dGluZ3Mudk1heH1dIHNldHRpbmdzYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvRm9ybWF0ID0gYXV0b0Zvcm1hdDtcblxuICAgIC8qKlxuICAgICAqIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyB1bmZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50XG4gICAgICovXG4gICAgYXV0b1VuRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmFEZWN9YDtcbiAgICAgICAgY29uc3QgYXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5CcmFja2V0ICYmIHNldHRpbmdzLm5CcmFja2V0LnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gbmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoYXV0b1N0cmlwLCAnJyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLCcsICcuJyk7XG4gICAgICAgIHZhbHVlID0gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLmxvY2FsZU91dHB1dCk7XG5cbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7IC8vRklYTUUgYHZhbHVlYCBoZXJlIGNvdWxkIGJlIGEgc3RyaW5nIChkZXBlbmRpbmcgb24gYGxvY2FsZU91dHB1dGApLCBzbyB3ZSBzaG91bGQgb25seSBjYXN0IGl0IHRvIGEgTnVtYmVyIHdoZW4gbmVlZGVkXG4gICAgfTtcblxuICAgICQuZm4uYXV0b1VuZm9ybWF0ID0gYXV0b1VuRm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIGdpdmVuIG9wdGlvbiBvYmplY3QuXG4gICAgICogSWYgdGhlIG9wdGlvbnMgYXJlIHZhbGlkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbm90aGluZywgb3RoZXJ3aXNlIGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgdGVzdHMgaWYgdGhlIG9wdGlvbnMgYXJlIG5vdCBjb25mbGljdGluZyBhbmQgYXJlIHdlbGwgZm9ybWF0dGVkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGVuaWVudCBzaW5jZSBpdCBvbmx5IHRlc3RzIHRoZSBzZXR0aW5ncyBwcm9wZXJ0aWVzIDsgaXQgaWdub3JlcyBhbnkgb3RoZXIgcHJvcGVydGllcyB0aGUgb3B0aW9ucyBvYmplY3QgY291bGQgaGF2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdXNlck9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIElmIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIGV4dGVuZHMgdGhlIGB1c2VyT3B0aW9uc2AgcGFzc2VkIGJ5IHRoZSB1c2VyLCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqL1xuICAgIHZhbGlkYXRlID0gKHVzZXJPcHRpb25zLCBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyA9IHRydWUpID0+IHtcbiAgICAgICAgY29uc3QgZGVidWcgPSB0cnVlOyAvLyBUaGUgZXJyb3IgaGVyZSBtdXN0IGFsd2F5cyBiZSB0aHJvd24sIHNpbmNlIGEgYmFkbHkgY29uZmlndXJlZCBvcHRpb25zIG9iamVjdCB3aWxsIGxlYWQgdG8gd3JvbmcgcmVzdWx0cywgaWYgYW55LlxuXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodXNlck9wdGlvbnMpIHx8ICFpc09iamVjdCh1c2VyT3B0aW9ucykgfHwgaXNFbXB0eU9iaih1c2VyT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB1c2VyT3B0aW9ucyBhcmUgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHZhbGlkIG9iamVjdCwgWyR7dXNlck9wdGlvbnN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdXNlciBjYW4gY2hvb3NlIGlmIHRoZSBgdXNlck9wdGlvbnNgIGhhcyBhbHJlYWR5IGJlZW4gZXh0ZW5kZWQgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLCBvciBub3RcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRlc3RQb3NpdGl2ZUludGVnZXIgPSAvXlswLTldKyQvO1xuICAgICAgICBjb25zdCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyA9IC9bMC05XSsvO1xuICAgICAgICAvLyBjb25zdCB0ZXN0RmxvYXRBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKykkLztcbiAgICAgICAgY29uc3QgdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspPyQvO1xuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlciA9IC9eWzAtOV0rKFxcLj9bMC05XSspPyQvO1xuXG4gICAgICAgIC8vIFRoZW4gdGVzdHMgdGhlIG9wdGlvbnMgaW5kaXZpZHVhbGx5XG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuYVNlcCwgWycsJywgJy4nLCAnICcsICcnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnYVNlcCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLCcsICcuJywgJyAnIG9yIGVtcHR5ICgnJyksIFske29wdGlvbnMuYVNlcH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLm5TZXApICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5uU2VwKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlICduU2VwJyBvcHRpb24gaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMublNlcH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZEdyb3VwKSkgeyAvLyBpc05hTihwYXJzZUludChvcHRpb25zLmRHcm91cCkpIC8vREVCVUdcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkaWdpdGFsIGdyb3VwaW5nIGZvciB0aG91c2FuZCBzZXBhcmF0b3Igb3B0aW9uICdkR3JvdXAnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRHcm91cH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuYURlYywgWycsJywgJy4nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdhRGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcuJyBvciAnLCcsIFske29wdGlvbnMuYURlY31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmQgY2hhcmFjdGVycyBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG9wdGlvbnMuYURlYyA9PT0gb3B0aW9ucy5hU2VwKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAnYURlYycgWyR7b3B0aW9ucy5hRGVjfV0gYW5kIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgJ2FTZXAnIFske29wdGlvbnMuYVNlcH1dIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXIuYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5hbHREZWMpICYmICFpc1N0cmluZyhvcHRpb25zLmFsdERlYykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhbHRlcm5hdGUgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnYWx0RGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLmFsdERlY31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFTaWduICE9PSAnJyAmJiAhaXNTdHJpbmcob3B0aW9ucy5hU2lnbikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXJyZW5jeSBzeW1ib2wgb3B0aW9uICdhU2lnbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5hU2lnbn1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMucFNpZ24sIFsncCcsICdzJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBjdXJyZW5jeSBzaWduIG9wdGlvbiAncFNpZ24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSBvciAncycgKHN1ZmZpeCksIFske29wdGlvbnMucFNpZ259XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLnBOZWcsIFsncCcsICdzJywgJ2wnLCAnciddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiBvcHRpb24gJ3BOZWcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSwgJ3MnIChzdWZmaXgpLCAnbCcgKGxlZnQpIG9yICdyJyAocmlnaHQpLCBbJHtvcHRpb25zLnBOZWd9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMuYVN1ZmZpeCkgfHwgKG9wdGlvbnMuYVN1ZmZpeCAhPT0gJycgJiYgKGNvbnRhaW5zKG9wdGlvbnMuYVN1ZmZpeCwgJy0nKSB8fCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycy50ZXN0KG9wdGlvbnMuYVN1ZmZpeCkpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGFkZGl0aW9uYWwgc3VmZml4IG9wdGlvbiAnYVN1ZmZpeCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBub3QgY29udGFpbnMgdGhlIG5lZ2F0aXZlIHNpZ24gJy0nIG5vciBhbnkgbnVtZXJpY2FsIGNoYXJhY3RlcnMsIFske29wdGlvbnMuYVN1ZmZpeH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMub0xpbWl0cykgJiYgIWlzSW5BcnJheShvcHRpb25zLm9MaW1pdHMsIFsnY2VpbGluZycsICdmbG9vcicsICdpZ25vcmUnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBvdmVycmlkZSBtaW4gJiBtYXggbGltaXRzIG9wdGlvbiAnb0xpbWl0cycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2NlaWxpbmcnLCAnZmxvb3InIG9yICdpZ25vcmUnLCBbJHtvcHRpb25zLm9MaW1pdHN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMudk1heCkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy52TWF4KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uICd2TWF4JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy52TWF4fV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLnZNaW4pIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMudk1pbikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAndk1pbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMudk1pbn1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KG9wdGlvbnMudk1pbikgPiBwYXJzZUZsb2F0KG9wdGlvbnMudk1heCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIDsgJ3ZNaW4nIFske29wdGlvbnMudk1pbn1dIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gJ3ZNYXgnIFske29wdGlvbnMudk1heH1dLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubURlYykgJiYgKCFpc1N0cmluZyhvcHRpb25zLm1EZWMpIHx8ICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5tRGVjKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ21EZWMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLm1EZWN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuYVBhZCAmJiAhaXNOdWxsKG9wdGlvbnMubURlYykpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ2FQYWQnIHRvIFtmYWxzZV0gd2lsbCBvdmVycmlkZSB0aGUgY3VycmVudCAnbURlYycgc2V0dGluZyBbJHtvcHRpb25zLm1EZWN9XS5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcml0ZSBhIHdhcm5pbmcgbWVzc2FnZSBpbiB0aGUgY29uc29sZSBpZiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgaW4gdk1pbi92TWF4IGlzIG92ZXJyaWRkZW4gYnkgbURlYyAoYW5kIG5vdCBpZiBtRGVjIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZGVjaW1hbCB1c2VkIGluIHZNaW4vdk1heClcbiAgICAgICAgbGV0IGRwVk1pbiA9IGRlY2ltYWxQbGFjZXMob3B0aW9ucy52TWluKTtcbiAgICAgICAgbGV0IGRwVk1heCA9IGRlY2ltYWxQbGFjZXMob3B0aW9ucy52TWF4KTtcbiAgICAgICAgZHBWTWluID0gaXNOdWxsKGRwVk1pbik/MDpkcFZNaW47XG4gICAgICAgIGRwVk1heCA9IGlzTnVsbChkcFZNYXgpPzA6ZHBWTWF4O1xuICAgICAgICBjb25zdCB2TWluTWF4RGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KGRwVk1pbiwgZHBWTWF4KTtcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5tRGVjKSAmJlxuICAgICAgICAgICAgKChoYXNEZWNpbWFscyhvcHRpb25zLnZNaW4pIHx8IGhhc0RlY2ltYWxzKG9wdGlvbnMudk1heCkpICYmIHZNaW5NYXhEZWNpbWFsUGxhY2VzICE9PSBOdW1iZXIob3B0aW9ucy5tRGVjKSkpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ21EZWMnIHRvIFske29wdGlvbnMubURlY31dIHdpbGwgb3ZlcnJpZGUgdGhlIGRlY2ltYWxzIGRlY2xhcmVkIGluICd2TWluJyBbJHtvcHRpb25zLnZNaW59XSBhbmQgJ3ZNYXgnIFske29wdGlvbnMudk1heH1dLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZURlYykgJiYgKCFpc1N0cmluZyhvcHRpb25zLmVEZWMpIHx8ICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5lRGVjKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBudW1iZXIgb2YgZXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdlRGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5lRGVjfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyBcImVEZWNcIiBpcyBncmVhdGVyIHRoYW4gdGhlIG5vcm1hbCBkZWNpbWFsIHBsYWNlcyBcIm1EZWNcIlxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmVEZWMpICYmICFpc051bGwob3B0aW9ucy5tRGVjKSAmJiBOdW1iZXIob3B0aW9ucy5tRGVjKSA8IE51bWJlcihvcHRpb25zLmVEZWMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyAnZURlYycgWyR7b3B0aW9ucy5lRGVjfV0gaXMgZ3JlYXRlciB0aGFuIHRoZSAnbURlYycgWyR7b3B0aW9ucy5tRGVjfV0gdmFsdWUuYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURpdmlzb3IpICYmICF0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlci50ZXN0KG9wdGlvbnMuc2NhbGVEaXZpc29yKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIGRpdmlzb3Igb3B0aW9uICdzY2FsZURpdmlzb3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIsIHByZWZlcmFibHkgYW4gaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURpdmlzb3J9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlRGVjaW1hbCkgJiYgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGVjaW1hbCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBudW1iZXIgb2YgZGVjaW1hbHMgb3B0aW9uICdzY2FsZURlY2ltYWwnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGVjaW1hbH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVTeW1ib2wpICYmICFpc1N0cmluZyhvcHRpb25zLnNjYWxlU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIHN5bWJvbCBvcHRpb24gJ3NjYWxlU3ltYm9sJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLnNjYWxlU3ltYm9sfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYVN0b3IpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5hU3RvcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzYXZlIHRvIHNlc3Npb24gc3RvcmFnZSBvcHRpb24gJ2FTdG9yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5hU3Rvcn1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMubVJvdW5kLCBbXG4gICAgICAgICAgICAnUycsXG4gICAgICAgICAgICAnQScsXG4gICAgICAgICAgICAncycsXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAnQicsXG4gICAgICAgICAgICAnVScsXG4gICAgICAgICAgICAnRCcsXG4gICAgICAgICAgICAnQycsXG4gICAgICAgICAgICAnRicsXG4gICAgICAgICAgICAnTjA1JyxcbiAgICAgICAgICAgICdDSEYnLFxuICAgICAgICAgICAgJ1UwNScsXG4gICAgICAgICAgICAnRDA1JyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSByb3VuZGluZyBtZXRob2Qgb3B0aW9uICdtUm91bmQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdTJywgJ0EnLCAncycsICdhJywgJ0InLCAnVScsICdEJywgJ0MnLCAnRicsICdOMDUnLCAnQ0hGJywgJ1UwNScgb3IgJ0QwNScgKGNmLiBkb2N1bWVudGF0aW9uKSwgWyR7b3B0aW9ucy5tUm91bmR9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hUGFkKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYVBhZCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjb250cm9sIGRlY2ltYWwgcGFkZGluZyBvcHRpb24gJ2FQYWQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFQYWR9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm5CcmFja2V0KSAmJiAhaXNJbkFycmF5KG9wdGlvbnMubkJyYWNrZXQsIFsnKCwpJywgJ1ssXScsICc8LD4nLCAneyx9J10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYnJhY2tldHMgZm9yIG5lZ2F0aXZlIHZhbHVlcyBvcHRpb24gJ25CcmFja2V0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnKCwpJywgJ1ssXScsICc8LD4nIG9yICd7LH0nLCBbJHtvcHRpb25zLm5CcmFja2V0fV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy53RW1wdHksIFsnZm9jdXMnLCAncHJlc3MnLCAnYWx3YXlzJywgJ3plcm8nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkaXNwbGF5IG9uIGVtcHR5IHN0cmluZyBvcHRpb24gJ3dFbXB0eScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycgb3IgJ3plcm8nLCBbJHtvcHRpb25zLndFbXB0eX1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMubFplcm8sIFsnYWxsb3cnLCAnZGVueScsICdrZWVwJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbGVhZGluZyB6ZXJvIGJlaGF2aW9yIG9wdGlvbiAnbFplcm8nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdhbGxvdycsICdkZW55JyBvciAna2VlcCcsIFske29wdGlvbnMubFplcm99XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hRm9ybSkgJiYgIWlzQm9vbGVhbihvcHRpb25zLmFGb3JtKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGZvcm1hdCBvbiBpbml0aWFsaXphdGlvbiBvcHRpb24gJ2FGb3JtJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5hRm9ybX1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNOdW1iZXIpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zTnVtYmVyKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNlbGVjdCBudW1iZXIgb25seSBvcHRpb24gJ3NOdW1iZXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNOdW1iZXJ9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmFuRGVmYXVsdCkgJiYgKG9wdGlvbnMuYW5EZWZhdWx0ICE9PSAnJyAmJiAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLmFuRGVmYXVsdCkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZSBvcHRpb24gJ2FuRGVmYXVsdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMuYW5EZWZhdWx0fV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMudW5TZXRPblN1Ym1pdCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLnVuU2V0T25TdWJtaXQpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcmVtb3ZlIGZvcm1hdHRpbmcgb24gc3VibWl0IG9wdGlvbiAndW5TZXRPblN1Ym1pdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMudW5TZXRPblN1Ym1pdH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubG9jYWxlT3V0cHV0KSAmJiAhaXNJbkFycmF5KG9wdGlvbnMubG9jYWxlT3V0cHV0LCBbXG4gICAgICAgICAgICAnLicsXG4gICAgICAgICAgICAnLS4nLFxuICAgICAgICAgICAgJywnLFxuICAgICAgICAgICAgJy0sJyxcbiAgICAgICAgICAgICcuLScsXG4gICAgICAgICAgICAnLC0nLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGN1c3RvbSBsb2NhbGUgZm9ybWF0IG9wdGlvbiAnbG9jYWxlT3V0cHV0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSBlbXB0eSwgJy4nLCAnLS4nLCAnLCcsICctLCcsICcuLScgb3IgJywtJywgWyR7b3B0aW9ucy5sb2NhbGVPdXRwdXR9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5kZWJ1ZykgJiYgIWlzQm9vbGVhbihvcHRpb25zLmRlYnVnKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnZGVidWcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmRlYnVnfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4udmFsaWRhdGUgPSB2YWxpZGF0ZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlzIHRoZSBzZXR0aW5ncy9vcHRpb25zIGFyZSB2YWxpZCwgRkFMU0Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBhcmVTZXR0aW5nc1ZhbGlkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWxpZGF0ZShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjdXN0b20gZXZlbnQuXG4gICAgICogY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGV0YWlsXG4gICAgICogQHJldHVybnMge0N1c3RvbUV2ZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCwgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlIH0pOyAvLyBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgZGVmYXVsdCBieSBJRSA7IFdlIHVzZSB0aGUgcG9seWZpbGwgZm9yIElFOSBhbmQgbGF0ZXIuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50IGFuZCBpbW1lZGlhdGVseSBicm9hZGNhc3QgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHN0cmluZ1xuICAgICAqIEBwYXJhbSBkZXRhaWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZW5kQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBkZXRhaWwgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnQgZm9yIG9ic29sZXRlIGJyb3dzZXJzIChJRSlcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdm9pZCgwKSB9O1xuICAgICAgICAgICAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfVxuXG4gICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuICAgIH0pKCk7XG59KSk7XG5cbi8qKlxuICogVGhpcyBleHBvcnRzIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBhdXRvTnVtZXJpYyBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGZvcm1hdCAgOiBhdXRvRm9ybWF0LFxuICAgIHVuRm9ybWF0OiBhdXRvVW5Gb3JtYXQsXG4gICAgZ2V0RGVmYXVsdENvbmZpZyxcbiAgICB2YWxpZGF0ZSwgLy8gYW4udmFsaWRhdGUob3B0aW9ucykgOiB0aHJvd3MgaWYgbmVjZXNzYXJ5XG4gICAgYXJlU2V0dGluZ3NWYWxpZCwgLy9hbi5hcmVTZXR0aW5nc1ZhbGlkKG9wdGlvbnMpIDogcmV0dXJuIHRydWUgb3IgZmFsc2UgLy9UT0RPIElzIHRoaXMgcmVkdW5kYW50PyBTaG91bGQgd2UgbGV0IHRoZSBkZXZlbG9wZXJzIHdyYXAgZWFjaCBhdXRvTnVtZXJpYy52YWxpZGF0ZSgpIGNhbGxzIGluIHRyeS9jYXRjaCBibG9jaz8gT3Igc2hvdWxkIHdlIGp1c3QgZmFjaWxpdGF0ZSB0aGVpciBsaWZlIGJ5IGRvaW5nIGl0IGFscmVhZHk/XG5cbiAgICAvL1RPRE8gQ29tcGxldGUgdGhlIGludGVyZmFjZSB3aXRoIGZ1bmN0aW9ucyBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaWduYXR1cmVzIDpcbiAgICAvL2luaXQgICAgICAgICA6IGFuLmluaXQob3B0aW9ucywgaW5wdXQpXG4gICAgLy9nZXQgICAgICAgICAgOiBhbi5nZXQoaW5wdXQpXG4gICAgLy9zZXQgICAgICAgICAgOiBhbi5zZXQodmFsdWUsIGlucHV0KVxuICAgIC8vZm9ybVN0cmluZyAgIDogYW4uZm9ybVN0cmluZyhmb3JtKVxuICAgIC8vZm9ybUFycmF5ICAgIDogYW4uZm9ybUFycmF5KGZvcm0pXG4gICAgLy9nZXRGb3JtYXR0ZWQgOiBhbi5nZXRGb3JtYXR0ZWQoaW5wdXQpXG4gICAgLy91bnNldCAgICAgICAgOiBhbi51bnNldChpbnB1dCkgLy90byByZW5hbWUgdG8gJ3VuZm9ybWF0Jz8gKGFuZCBtZXJnZSB3aXRoIGF1dG9VbkZvcm1hdC91bkZvcm1hdD8pXG4gICAgLy9yZWZvcm1hdCAgICAgOiBhbi5yZWZvcm1hdChpbnB1dCkgLy8gJ3JlU2V0JyBpcyB2ZXJ5IHRvIGNsb3NlIHRvICdyZXNldCcgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgcmVuYW1lZC4gV2UgY291bGQgc3RpbGwgZXhwb3NlICdyZVNldCcsIGJ1dCBhZGQgYSBAZGVwcmVjYXRlZCB0YWcgb24gaXRzIGRlY2xhcmF0aW9uLlxuICAgIC8vc2V0dGluZ3MgICAgIDogYW4uc2V0dGluZ3MoaW5wdXQpXG4gICAgLy91cGRhdGUgICAgICAgOiBhbi51cGRhdGUob3B0aW9ucywgaW5wdXQpXG4gICAgLy93aXBlICAgICAgICAgOiBhbi53aXBlKGlucHV0KVxuICAgIC8vZGVzdHJveSAgICAgIDogYW4uZGVzdHJveShpbnB1dClcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXV0b051bWVyaWMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;